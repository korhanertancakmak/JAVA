In the last several videos, I've been focusing
on DML, or Data Manipulation Language, because in
many ways it's easier to learn and understand.
In this video, I'll use the methods I've been
covering, but apply them to Data
Definition Language, or D D L.
I've created a new project, which I've called
JDBCChallenges, with the usual Main class.
I need to include the JDBC driver again
in this project, so I'll Right Click,
and select Module Settings, or in
windows, that's F4 for the shortcut key.
Select Libraries on the dialog that appears.
Select The Plus Sign icon, and Select
Java as the option.
You'll get a file dialog,
and hopefully you'll remember where you
downloaded the my SQL connecter J jar file.
I'll select mine, and I'll press
OK, to any dialog that follows.
And that's it.
Now, I'll go to my Main class.
I'll set up a static query
string, so private, static,
final, String, USE underscore SCHEMA, and I'll
set that to the literal text, USE Store front.
This statement is a DDL statement. It sets
the default database for the session.
I'll use this statement, to test if I
need to create the storefront database.
To do this, in the main method,
I'll set up a basic datasource.
Since I'm running in a standalone



environment, I'll create a new instance,
using the class name of the my SQL
data source. I'll set the server name,
localhost, and the port, 3 3 0 6. I'll set
the user, to be an environment variable,
which I've done before. I'll do
the same thing for the password.
Notice that here, I'm not specifying
any schema or database name,
when I'm setting up the data source.
That's because I plan to create it.
First though, I'll set up a method, to test
if the database exists, so I'll create that.
I'll make this private and
static, and return a boolean.
I'll call it checkSchema, and
pass it an existing connection.
It's complaining about the import, I'll fix that
in a bit. I'll create a new statement object,
in a try with resources. I'll execute the USE
SCHEMA statement. If this throws an exception,
I'll print the stack trace. And return false, if I
do get an exception. Otherwise, I'll return true.
If you get into a situation
where IntelliJ doesn't show
the import popup, do this to force the popup.
We want to choose java.sql Connection here.
This should fix the import for Statement as well.
Scrolling up you can see it has.
Next, I'll call this method from the main method.
I'll use a try with resources, to first get the
connection from the data source,
with the getConnection method. I'll execute checkSchema,
as part of an if condition. So if
it returns false, I'll print that
the storefront schema doesn't exist.
AndI'll set up the usual catch clause here.
I'll set up my environment variables,
as part of the run configuration.



You've seen me do this several times
by now, so I'll just do it real quick.
So Run, Edit Configurations.



In the environment variables input field,
I'll set up My SQL User, equal to dev user, then I need
to follow that with a semi colon, not a comma.
Then I'll type My SQL, P A S S
and set that to my password.
You'd put your own password there.
Now I can run this code.



And sure enough, I get unknown
database, store front.
Now in truth, the code in the checkSchema method
is flawed, since it just assumes any exception
thrown, means that the database doesn't exist.
A lot of problems could happen here,
that have nothing to do with whether
this database exists or not.
The SQL Exception comes with
additional information we can examine.
This includes an SQL state String, derived
from a list of codes, from one of two
possible conventions used to standardize codes.
To figure out which convention the driver uses,
we can query a class called DatabaseMetaData,
which we can get from the connection.
Next, there's an integer error code,
that's specific to each vendor.
These codes can often help determine, with
more accuracy, the exact error that occurred.
Before I add any more code, I'll show you how to
get information from the database metadata class.
This can be retrieved from the connection
object, with a method called getMetaData.
I'll add this code as the first
statement inside the try block
I'll create a variable called metaData, assign
it the value I get from the getMetaData method.
I'll pause after I type metadata dot.
I want you to see the many things you can
learn about your database, from this instance.
If you're writing JDBC code, you really should try
to be familiar with your driver's features, and
this class and its methods, will help you explore
the driver configuration, and database specifics.
In this case I want to execute getSQLStateType,
so I'll scroll down and select that.
I'll run the code again.



Notice, that a 2 is printed
out, before the exception.
That's not immediately useful information.
I'll control click, on the class
DatabaseMetaData,
and search for SQLState.
Here you can see there's a couple of constant values,
and the s q l state S Q L is set to 2.
This indicates this driver is using the latest SQL conventions,
and not the X OPEN conventions.
I'll show you how to look codes up, using one of
these conventions, in a minute.
First, I'll write some code,
to explore the error I got back.
I'll add this code after the printStackTrace,
in the checkSchema method.
I'll print the SQL State first.
Then the error code,
and finally the message.
Notice here, I'm using System.err, and not System.out,
which I don't think I've used before.
System.err is standard output for errors.
In our case System.err and System.out
both output to the console.
If you're working in a production client
server environment, it's good practice to
output errors to System.err.
These messages get displayed,
even if System.out messages get redirected
to a file, or some other output stream.
Configuring standard streams, to
different output sources is more common,
in a client server environment.
I'll run this code again.



Now I've got S Q L state = 42 thousand.
And Error Code = 10 49.
And the message is, unknown database storefront.
I'll go to a browser and type 'wiki SQL STATE'.
This brings up the wikipedia
page, for SQL State values.
Here, I'll search for 42000.
The message for this code is,
syntax error or access rule violation.
Since these are standard codes,
it's a good idea to try to use these if
you can, versus the database vendor code.
For this scenario though, that
code is not super useful.
We don't really know if we have a
syntax error, it's an access issue,
or the schema just doesn't exist.
Now let's look up the MySQL Error code.
I'll pull up the server error reference
page on My SQL's documentation.
I'll search for 10 49.
And here, you see the MySQL string code, and
that's followed by the SQL State, 42 thousand.
This is followed by a specific message,
unknown database, which was
printed in the exception we got.
Let's search for 42 000 on this page.
You can see, there are many errors that
fall into that state.
I'll change the code,
to test the more specific MySQL error code.
First, I'll set up a constant on my class.
I'll call this My SQL DB NOT
FOUND, and assign that, 1 0 4 9.
Next, in my exception clause, I'll test both
the database product name, and the error code.
If my database product is my SQL, and the error
code is 10 49, then I know for sure the schema
doesn't exist, in the MySQL server.
I'll remove the return false statement,
and replace it with the following code.
I'll use getMetaData, and chain the
getDatabaseProductName to that, and compare
that value to the literal string value,
MySQL. Additionally, I'll check if the
error code equals my SQL DB NOT FOUND's value.
 If both these conditions are
true, then I'll return false, meaning
the storefront database doesn't exist. Otherwise,
I'll propagate the error out to the main method.
This code doesn't compile though, because I need
to catch or specify, so I'll include the throws
SQL exception, in the method declaration.
I'll just add that manually.
Let's run this again.



I get the same result, but now I have confidence
that I know exactly what the problem is.
I wanted to spend a little extra time
with SQL exceptions, because it's important to
understand as much about the error as possible,
that's returned from the database server.
Ok, so let's create the storefront now.
I'll create a new method, that'll
be private and static, returns void,
and I'll call it setUpSchema.
It'll take a connection,
throwing an SQL Exception.
Remember that for My SQL, the terms database
and schema are used interchangeably, so the first
statement I need is, CREATE SCHEMA storefront,
which will create the storefront database when
executed. My first table, is the order table,
so I'll have a createOrder string using a textblock,
The DDL I need is, CREATE table, storefront.order,
followed by an opening parentheses. That's
followed by a list of columns, and types.
My first column is order id, an int, it can't be null, and
it's going to auto increment. Next, order date,
a datetime field, and again that should never be
null. I need to specify the primary key, which
is order id. A closing parentheses ends the column
list, and that's all I need to create this table.
I'll add a second table, that has a
relationship to the first, named order details.
This will be similar to the code for order.
So create table, storefront.order_details, left parenthesis.
The order detail id, an int, can't be
null, and gets auto incremented. Item description,
is a text field. The third column is order_id.
This is the column that connects the two tables.
My primary key is order detail id. But there's
another key, a foreign key. It's pretty common,
to prefix a foreign key with FK, so I'll call it
FK_ORDER ID. This foreign key is on the column,
order id. Next, I have to describe what's
called a constraint. This describes both
the relationship to the other table, as well as
limitations or constraints on table processing.
So order id in this table, references order id
in the parent table, storefront.order.
This time,I want a delete to cascade to its child records.
This code will set up a parent child relationship between these two tables.
And importantly, they are treated like a
single unit when I delete the parent.
This means, if I delete an order,
the details will also get deleted.
Don't worry if you don't understand
all of this SQL code.
My goal here is first,
to show you that whether you execute DML, or
DDL, the process to do it in Java, is the same.
There is one significant difference
I want to note, however.
You can't roll back many of the DDL statements, so
it's less common to execute DDL in a transaction.
Whether or not you can execute DDL
statements in a transaction, is
something that's specific to the database vendor.
The second objective of this exercise, was to give
you a schema, for upcoming challenges.
Now, I have to add the code
to execute these statements.
I'll use a try with resources again,
Creating a statement within that. I'll print
that this is creating a storefront database.
I'll call execute on my createSchema first.
I'll double check that it really got created,
by calling checkSchema. If that's true, I'll
create the order table. I'll print that it was. created.
I'll execute the creation of the order
details table next. And I'll again print that
it was successfully created. Otherwise,
I'll catch the exception and print it.
I'll add the call to this
method in the main method.
I'll put it in the if statement, after
the system.out.println statement.
I need to pass that the connection instance.
Before I run this, I'm going to first open a



session, in My SQL WorkBench, for my dev user.
I'll use the workbench, to independently
confirm the schema and tables got added.
Getting back to IntelliJ, I'll run my code.



Everything seems to have worked fine.
I get that the application successfully
created order, and order details, and
that the storefront schema was created.
Jumping back to My SQL Workbench,
I'll refresh the schema panel.
The refresh icon is on the
right of the SCHEMAS label.
When I click on that,
I should now see the storefront schema listed.
I'll expand that, and I'll expand Tables, and
there I can see my two tables that were created
by the Java code, Order and Order Details.
If you have any problems at all with your own
code, you can right click on the
storefront schema in this tool,
and select drop schema, then try your java code
again, to recreate the schema from scratch again.
Ok, so I'm going to bring this video to a close.
Hopefully you were able to follow along and
you've got a storefront schema
set up, and ready to be used.
In the next video, I'll have a challenge,
using this schema, so keep this project open.
