WEBVTT
Kind: captions
Language: en

00:00:05.400 --> 00:00:10.235
There are many challenges and concerns, when
you're working with databases via JDBC.


00:00:11.080 --> 00:00:12.394
I've listed many of them here.

00:00:13.320 --> 00:00:17.828
This can be a daunting list for a Java
developer, whose not an expert in databases.


00:00:18.720 --> 00:00:22.640
If you're working in an environment that's
using an enterprise database, you've probably

00:00:22.640 --> 00:00:26.840
got people on your team, who have a lot more
knowledge about many of these issues than you do,

00:00:26.840 --> 00:00:31.680
or can hope to learn in a short time.
For this reason, the best place to deal

00:00:31.680 --> 00:00:35.141
with many of these issues, is
on the database server itself.


00:00:36.080 --> 00:00:42.162
If you've got Database Administrators or DBAs, and
S Q L Developers, your job will get a lot easier.


00:00:42.960 --> 00:00:48.120
They'll tackle many of these issues with database
server features, like indices, constraints,

00:00:48.120 --> 00:00:52.600
triggers, and stored procedures.
They'll puzzle over explain plans

00:00:52.600 --> 00:00:56.515
for performance issues, and write all
kinds of monitoring and logging code.


00:00:57.360 --> 00:01:01.000
They're often experts in tuning queries,
so who better to write your queries than

00:01:01.000 --> 00:01:04.720
this impressive group of people.
Even if you don't have access to

00:01:04.720 --> 00:01:08.720
this talent pool, You should consider
addressing, at least some of the problems

00:01:08.720 --> 00:01:14.480
listed on this slide, with server solutions.
This is often done with functions and routines,

00:01:14.480 --> 00:01:20.127
written in SQL, or transactional or procedural
languages, that integrate easily with SQL.


00:01:21.043 --> 00:01:25.840
These items are often called stored procedures as
a category, though there are two separate database

00:01:25.840 --> 00:01:32.160
artifacts, the procedure and the function.
Stored procedures are a way to encapsulate

00:01:32.160 --> 00:01:37.040
complex SQL logic, and data
manipulation, into reusable modules,

00:01:37.040 --> 00:01:41.600
that can be called from within the database.
They can help to improve application

00:01:41.600 --> 00:01:48.320
performance, modularity, and security.
They're precompiled queries, or segments of code,

00:01:48.320 --> 00:01:54.440
that are stored as just another database object.
Your JDBC code can be simplified quite a bit,

00:01:54.440 --> 00:01:57.242
if you're able to take
advantage of stored procedures.


00:01:58.040 --> 00:02:03.200
A stored procedure can also be written
externally, in Java, Python, or c, and

00:02:03.200 --> 00:02:07.842
stored with a wrapping procedure in the database,
which means that code will run on the server.


00:02:08.640 --> 00:02:12.640
I won't be covering this last bit, but
you should know that some databases,

00:02:12.640 --> 00:02:17.651
like S Q L Lite and H2, only support these
external types of stored procedures.


00:02:18.520 --> 00:02:22.564
I'll be covering functions in a later video,
and will explain the differences later.


00:02:24.560 --> 00:02:29.440
It's very common in an enterprise environment, to
protect access to the database, and to restrict

00:02:29.440 --> 00:02:33.960
what your clients are allowed to do.
Because of this, you might find that

00:02:33.960 --> 00:02:39.360
most of your JDBC work, will be done
with requests to stored procedures.


00:02:39.360 --> 00:02:44.920
Java supports the execution, and retrieval of
results, from these code segments, with a special

00:02:44.920 --> 00:02:50.720
kind of statement, named the CallableStatement.
Like a PreparedStatement, this first takes a

00:02:50.720 --> 00:02:55.480
parameterized string, when you get an instance.
The object referenced will already

00:02:55.480 --> 00:03:00.680
be compiled in the database server.
Like a method in Java, you pass in data with

00:03:00.680 --> 00:03:07.160
parameters, and you may or may not get data back.
Depending on your database, the data coming back

00:03:07.160 --> 00:03:09.760
might be a result returned
from a function, or it could

00:03:09.760 --> 00:03:15.960
be returned with declared output parameters.
Some databases also support a hybrid parameter,

00:03:15.960 --> 00:03:19.120
an input output parameter, which
lets you pass data which may be

00:03:19.120 --> 00:03:25.120
modified by the procedure, and passed back.
I'll explain these parameters a bit more later,

00:03:25.120 --> 00:03:30.332
as we explore how to use the CallableStatement.
First, we need access to one.


00:03:32.680 --> 00:03:38.148
I've included a DDL script in the resources folder
of this lecture, named add Album Songs dot S Q L.


00:03:39.040 --> 00:03:42.960
You should download that script, and put
it somewhere on your local file system,

00:03:42.960 --> 00:03:47.800
where you can access it easily.
Next, open MySQL Workbench, to your

00:03:47.800 --> 00:03:49.162
development connection.

00:03:55.150 --> 00:03:58.512
In this case,you'll select the second SQL Editor icon,

00:04:00.954 --> 00:04:03.338
which will prompt you to open an S Q L script.


00:04:04.160 --> 00:04:07.707
Find the script you downloaded, and
select it, and hit the open button.


00:04:09.280 --> 00:04:14.760
That should load this script in your edit panel.
Now, you just want to execute this script, so the

00:04:14.760 --> 00:04:21.080
first lightning bolt icon there, will do it.
If you refresh the schema panel, you should

00:04:21.080 --> 00:04:26.167
confirm that you see this new procedure, named
add Album, under the Stored Procedures listing.


00:04:27.200 --> 00:04:29.788
Click on that, and select the
wrench or tool icon there.


00:04:31.240 --> 00:04:36.240
This will load up the stored procedure's code.
I won't get into this code too much,

00:04:36.240 --> 00:04:40.000
but what you do need to know, is what
the parameters are, to this routine.


00:04:40.920 --> 00:04:46.560
There's three of them, an artist name,
a text field, an album name, also text,

00:04:46.560 --> 00:04:52.320
and the last is songs, a jayson type.
MySQL stored procedures don't currently

00:04:52.320 --> 00:04:56.917
support arrays, but they do support
jayson objects, which can include arrays.


00:04:57.880 --> 00:05:01.800
In this case, this is a way to pass an
array of text, which will be an array

00:05:01.800 --> 00:05:06.480
of song titles to this stored procedure.
This code will add the artist if it's not in

00:05:06.480 --> 00:05:13.040
the database, or get the artist id if it is.
It'll then add the album if it's not there,

00:05:13.040 --> 00:05:17.680
then inserts all the songs associated with that
album, looping through the songs parameter,

00:05:17.680 --> 00:05:22.560
using MySQL JSON functions.
All three of these parameters

00:05:22.560 --> 00:05:25.985
are input parameters.
How do I know?


00:05:26.760 --> 00:05:32.200
If you don't see one of the keywords, in, OUT, or
in OUT, then the parameter is by default an input

00:05:32.200 --> 00:05:37.120
parameter, so the keyword in, is implied.
This is important to know,

00:05:37.120 --> 00:05:41.680
for the callable statement.
Before we get back to IntelliJ,

00:05:41.680 --> 00:05:45.435
let's make sure we've removed any Bob
Dylan records in the music data set.


00:05:46.280 --> 00:05:49.804
I'll open another SQL edit panel,
and type in a delete statement.


00:05:50.720 --> 00:05:56.637
So delete from music.artists, where artist name,
equals Bob Dylan, with his name in single quotes.


00:05:57.600 --> 00:06:02.200
In this case, I'm using all lower case
for the SQL keywords as I type it in,

00:06:02.200 --> 00:06:07.520
since this is just an adhoc query.
I told you to use uppercase for SQL keywords,

00:06:07.520 --> 00:06:11.470
and I know I haven't always been consistent,
and will sometimes forget to do it myself.


00:06:12.480 --> 00:06:17.268
There's a beautify reformat option in this SQL
Edit panel, and that's the little broom icon.


00:06:18.160 --> 00:06:22.800
I'll click that.
I don't always like the way it reformats it, but

00:06:22.800 --> 00:06:28.160
it does change the keywords, to be upper case.
Sometimes I just want my query to be on a

00:06:28.160 --> 00:06:31.247
single line and quickly execute
it, so I may not beautify it.


00:06:32.280 --> 00:06:36.320
But if I am using the code in a JDBC
statement, or a stored procedure,

00:06:36.320 --> 00:06:38.627
I do try to be more disciplined.
At any rate, I'll execute this statement.


00:06:39.590 --> 00:06:43.867
I'll execute that, so that the music
database won't have any data for Bob Dylan,

00:06:43.867 --> 00:06:49.120
when we first execute this procedure.
You'll hopefully remember, that we added cascade

00:06:49.120 --> 00:06:54.195
deletes on the albums and songs, so this single
statement, will clean up all that related data.


00:06:55.040 --> 00:06:59.400
Switching back to IntelliJ, I'll reopen
the PreparedStatement project again.


00:07:01.400 --> 00:07:05.887
I'll create a new class in the dev lpa package,
which I'll call MusicCallableStatement,

00:07:10.560 --> 00:07:15.781
and it'll have a main method.
I'll start by setting up a couple of constants.


00:07:16.720 --> 00:07:20.924
These constants just represent the column
index of the data, in the csv file.


00:07:21.840 --> 00:07:27.080
So the artist name is in the first column,
so artist column equals zero. The Album's

00:07:27.080 --> 00:07:33.077
in the next column, index 1. The song
title's in column 4, so index 3 here.

00:07:34.040 --> 00:07:40.000
I'm not going to use track number in this case.
The stored procedure will assign the track number

00:07:40.000 --> 00:07:45.040
in order, based on the order of the songs.
I'll be setting this up as a Map,

00:07:45.040 --> 00:07:52.680
keyed by string, with a nested map as the value.
I'll set up my map variable. It's value is a map,

00:07:52.680 --> 00:07:58.357
keyed by string, with a value of string. I'll
call this albums and initialize it to null.


00:08:00.200 --> 00:08:04.034
I'll show you another way to read the
song data, from the NewAlbums.csv.


00:08:05.000 --> 00:08:08.881
This time, I'll use the lines method,
which returns a stream of string.


00:08:09.880 --> 00:08:14.400
All of this is a good review, of streams,
and it'll actually make passing the data,

00:08:14.400 --> 00:08:20.560
to the stored procedure, a bit easier.
Just a reminder, that when you call Files.lines,

00:08:20.560 --> 00:08:26.797
you should do it in a try with resources, so the
stream is automatically closed. I'll do that here.

00:08:27.643 --> 00:08:34.400
Inside the try clause, I'll set up a variable,
simply called lines. I'll call Files.lines,

00:08:34.400 --> 00:08:41.879
with a Path, to the new albums.csv file, in the
project folder. That returns a stream of strings.


00:08:43.640 --> 00:08:47.575
I've got an error on the lines method, because I
need to include a catch clause,

00:08:47.575 --> 00:08:50.930
so I'll hover over that error, and pick, add catch clause.

00:08:54.805 --> 00:08:57.697
Inside the try block, I'll set up the stream pipeline.

00:08:59.552 --> 00:09:02.467
So the first thing I'll do is, split each line by the comma.

00:09:03.524 --> 00:09:08.320
I do this with the map operation,
and a lambda that splits the string. This means

00:09:08.320 --> 00:09:14.080
my stream goes from a stream of strings, to a
stream of arrays of strings. I'll collect this

00:09:14.080 --> 00:09:21.400
data into a map, with Collectors.grouping by.
The first level is grouped by the artist. Now,

00:09:21.400 --> 00:09:27.200
my file only has Bob Dylan as an artist, but let's
just say we didn't know that. The first level of

00:09:27.200 --> 00:09:33.560
the mapping, is the artist. The next grouping is
the album, I'll call Collectors.grouping By again,

00:09:33.560 --> 00:09:39.745
and pass the value in the album column. Then, I
need to get at the song column to collect the song titles.

00:09:40.543 --> 00:09:46.920
I'll do this with mapping, returning only
the song title. Next, I'll use collectors.joining,

00:09:46.920 --> 00:09:52.160
which ultimately uses StringJoiner. The goal
here is to make this look like a jayson array,

00:09:52.160 --> 00:09:57.240
which really just looks like a printed array.
The delimiter is a comma, but I also need to

00:09:57.240 --> 00:10:01.560
wrap each song title in double quotes, so I
escape that with a back slash, on either side

00:10:01.560 --> 00:10:06.600
of the comma. and that'll be wrapped in square
brackets, which will be my prefix and suffix

00:10:06.600 --> 00:10:12.840
elements. I need the starting double quote
as well, for the prefix. The same goes for

00:10:12.840 --> 00:10:19.405
the closing double quote, and closing bracket.
I'll print this out, so you can see the result.


00:10:20.720 --> 00:10:24.480
I'll loop through the albums, the key was
the artist name, and the value is that

00:10:24.480 --> 00:10:31.440
artist's albums. Next, I'll loop through the
nested map's data. The key is the album name,

00:10:31.440 --> 00:10:36.500
and the value is the string value, the
array of songs. I'll print that out.


00:10:40.680 --> 00:10:41.781
I'll run this.

00:10:45.703 --> 00:10:47.703
And you can see this file has two albums,

00:10:47.703 --> 00:10:50.640
and I've got all the
songs in a single comma delimited string,

00:10:50.640 --> 00:10:53.672
each song title enclosed, in double quotes.


00:10:58.087 --> 00:11:01.092
Next, I'll go over to the Main class from a previous video,

00:11:01.092 --> 00:11:03.737
and I basically want
to copy the entire main method.


00:11:07.800 --> 00:11:10.538
And I'll paste that at the end of
the main method in the Main class.


00:11:15.000 --> 00:11:18.040
I'll remove the code that sets
the continue batch on error flag,

00:11:18.040 --> 00:11:23.520
so that first pasted try catch block.
I don't need to worry about this now,

00:11:23.520 --> 00:11:26.501
because my stored procedure will
handle the entire transaction.


00:11:27.440 --> 00:11:30.237
I'll also remove the call to the
add data from File method there.


00:11:33.360 --> 00:11:37.280
I'll keep the select statement there, and the
prepared statement that uses that, just to

00:11:37.280 --> 00:11:42.120
confirm that data does really get added.
Here is a case where I missed making an SQL

00:11:42.120 --> 00:11:46.493
keyword uppercase, so I'll change the case
of the where clause, in this statement.


00:11:48.560 --> 00:11:52.748
I've got a compiler error on printRecords,
because that method's on the Main class.


00:11:53.640 --> 00:11:58.040
I'll open the Main class, and change the
modifier from private to public on that method.


00:11:59.003 --> 00:12:04.120
Now, back to the MusicCallableStatement class,
I can just prefix the method printRecords,

00:12:04.120 --> 00:12:11.160
with the class name, Main.
Ok, so now that this code compiles,

00:12:11.160 --> 00:12:16.371
I'll add some code, at the start of this try
block, before my first S Q L statement there.


00:12:17.240 --> 00:12:20.668
I'll be executing the stored
procedure, using a Callable Statement.


00:12:21.560 --> 00:12:25.680
You get a callable statement, much in the
same way as a preparedStatement, but you

00:12:25.680 --> 00:12:32.760
invoke prepare call. And you pass that an S Q L
string. To execute a procedure in the database,

00:12:32.760 --> 00:12:38.800
you usually use the keyword call, followed by the
procedure name. Again, I'll prefix that with the

00:12:38.800 --> 00:12:46.080
schema name. And like a prepared statement, I use
a question mark for parameters. In this case, the

00:12:46.080 --> 00:12:51.920
stored procedure has three parameters, so I'll put
three question marks there. A CallableStatement

00:12:51.920 --> 00:12:55.952
also gets parsed and compiled, which means
I can re use this statement efficiently.


00:12:59.483 --> 00:13:04.484
Next, I'll use my albums map, looping through
the keys and values, with a for each method.


00:13:05.400 --> 00:13:12.400
The key is the artist, and the value is the nested
map. I'll again use for each, and now the key is

00:13:12.400 --> 00:13:18.720
the album, and the value is the songs array, a
string, a jayson array. I have to include a try

00:13:18.720 --> 00:13:24.560
catch in this lambda expression. Like a prepared
statement, I set the values for the placeholders,

00:13:24.560 --> 00:13:31.065
so first the artist, then the album, And next
is the jayson, which is really just a string ultimately.

00:13:31.957 --> 00:13:36.920
I can run this, using the execute
method. This stored procedure doesn't return any

00:13:36.920 --> 00:13:43.266
data back. If I get an exception, I'll print the
more specific vendor error code and the message.


00:13:48.080 --> 00:13:52.040
And that's all I need.
Before I run this, I have to set up

00:13:52.040 --> 00:13:57.000
my system environment variables, as usual.
I know for the challenge video,

00:13:57.000 --> 00:14:00.254
I used environment variable names
that didn't include the underscores.


00:14:01.240 --> 00:14:06.200
I hope that didn't confuse you. It doesn't
really matter what the variable names really are,

00:14:06.200 --> 00:14:10.000
butI'll switch back here, and continue
with these names, moving forward.


00:14:10.960 --> 00:14:15.833
That's done in the run configuration.
Once I have that set up, I'll run this code.


00:14:20.483 --> 00:14:24.680
Here, you can see the data in the album view,
which confirms that I successfully added the

00:14:24.680 --> 00:14:30.120
artist, the two albums, and all the related
songs in that csv file, with just two method

00:14:30.120 --> 00:14:35.880
calls, to code stored in the database.
Some database vendors do support arrays,

00:14:35.880 --> 00:14:39.710
but MySQL is not one of them, so that's
why I used the jayson workaround.


00:14:40.720 --> 00:14:44.868
As I've said, it's important to understand
what features your RDMBS supports.


00:14:45.760 --> 00:14:49.040
If you're using callable statements,
it's less likely you're concerned about

00:14:49.040 --> 00:14:54.880
being database agnostic with your JDBC code.
So In this instance, I showed you an example

00:14:54.880 --> 00:14:59.877
of a stored procedure, that took three input
parameters, and didn't return any data back.


00:15:00.840 --> 00:15:04.743
In the next video, I'll cover in, and
out, parameters, and how to use them.


00:15:05.800 --> 00:15:08.560
Ok let's move on, andI'll
see you in that next video.
