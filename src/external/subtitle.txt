WEBVTT
Kind: captions
Language: en

00:00:05.280 --> 00:00:09.760
So far, in this section of the course,&nbsp;
I've focused on JDBC as the means for&nbsp;&nbsp;

00:00:09.760 --> 00:00:13.800
communicating with a database.
This is for good reason,&nbsp;&nbsp;

00:00:13.800 --> 00:00:19.920
since it's part of Java's Standard Edition&nbsp;
implementation, or core Java in other words.&nbsp;

00:00:19.920 --> 00:00:25.480
We've walked through writing SQL statements, and&nbsp;
executing them for the usual CRUD functionality.&nbsp;

00:00:25.480 --> 00:00:29.520
I've also demonstrated that this work can&nbsp;
be more tightly knit to the database server,&nbsp;&nbsp;

00:00:29.520 --> 00:00:34.400
by utilizing stored procedures that have&nbsp;
been written, to do some of the work for you.&nbsp;

00:00:34.400 --> 00:00:39.520
Even so, you're still in the business of&nbsp;
having to write some database interaction code.&nbsp;

00:00:39.520 --> 00:00:45.800
The alternative is something called the&nbsp;
Java Persistence API, or JPA for short.&nbsp;

00:00:45.800 --> 00:00:49.440
JPA is a specification.
There's no default&nbsp;&nbsp;

00:00:49.440 --> 00:00:54.560
implementation of the specification,&nbsp;
provided in Java's Standard Edition.&nbsp;

00:00:54.560 --> 00:00:58.400
That being said, I still want&nbsp;
to cover the topic briefly.&nbsp;

00:00:58.400 --> 00:01:03.480
There's a very good chance, you'll be working&nbsp;
on an application that uses some form of it.&nbsp;

00:01:03.480 --> 00:01:09.960
Some popular implementations are Hibernate,&nbsp;
Spring JPA, and EclipseLink, to name a few.&nbsp;

00:01:09.960 --> 00:01:16.040
These are called JPA Providers.
In 2019, the Java Persistence API officially&nbsp;&nbsp;

00:01:16.040 --> 00:01:22.160
changed its name, to Jakarta Persistence API.
It was previously part of Java's Enterprise&nbsp;&nbsp;

00:01:22.160 --> 00:01:26.960
Edition, which has since become open source.
The Persistence API became&nbsp;&nbsp;

00:01:26.960 --> 00:01:31.640
one of the Jakarta projects.
The link shown on this slide, is Jakarta's&nbsp;&nbsp;

00:01:31.640 --> 00:01:37.880
API documentation for JPA, and unless you're&nbsp;
supporting legacy code, you should start here.&nbsp;

00:01:37.880 --> 00:01:39.120
https://jakarta.ee/specifications/persistence/3.1/apidocs/jakarta.persistence/module-summary.html&nbsp;

00:01:39.120 --> 00:01:42.800
A few of the key concepts of&nbsp;
the JPA specification include&nbsp;

00:01:42.800 --> 00:01:49.400
A technique known as Object-Relational Mapping,&nbsp;
or ORM. The Entity (which is the mapped object),&nbsp;&nbsp;

00:01:49.400 --> 00:01:51.920
and the Entity Manager which manages lifecycles of&nbsp;&nbsp;

00:01:51.920 --> 00:01:58.440
these entities. The Persistence Context is a&nbsp;
special cached area where the entities exist.&nbsp;

00:01:58.440 --> 00:02:03.200
You can think of JPA as an extra layer of&nbsp;
functionality, between your application code,&nbsp;&nbsp;

00:02:03.200 --> 00:02:10.040
and the JDBC code you saw in the last lectures.
Object-Relational Mapping is a method of mapping&nbsp;&nbsp;

00:02:10.040 --> 00:02:16.560
database tables defined by columns, to a class&nbsp;
with correlated fields, and setters and getters.&nbsp;

00:02:16.560 --> 00:02:21.600
A record in a table then becomes an&nbsp;
instance. of one of these classes.&nbsp;

00:02:21.600 --> 00:02:25.800
ORM frameworks often automate the&nbsp;
process of object relational mapping.&nbsp;

00:02:25.800 --> 00:02:31.480
They Simplify code, reducing the need to&nbsp;
write boilerplate classes. They Simplify&nbsp;&nbsp;

00:02:31.480 --> 00:02:36.880
database operations, hiding the complexities of&nbsp;
SQL queries, and handling database interactions&nbsp;&nbsp;

00:02:36.880 --> 00:02:43.280
for you. They Provide code portability&nbsp;
across different database systems. ORM&nbsp;&nbsp;

00:02:43.280 --> 00:02:49.400
Frameworks also Encourage a more structured&nbsp;
and organized approach, to data access.&nbsp;

00:02:49.400 --> 00:02:54.680
Typically, an Entity is a class that&nbsp;
represents a table in a relational database.&nbsp;

00:02:54.680 --> 00:02:58.520
Each Entity instance corresponds&nbsp;
to a row in that table.&nbsp;

00:02:58.520 --> 00:03:03.760
Each entity is annotated with metadata, to&nbsp;
instruct JPA providers, how to map its fields to&nbsp;&nbsp;

00:03:03.760 --> 00:03:10.360
a table's columns, relationships to other tables,&nbsp;
and lifecycle management techniques to use.&nbsp;

00:03:10.360 --> 00:03:15.200
The example on this slide is a relatively&nbsp;
simple one, of an annotated class, Artist,&nbsp;&nbsp;

00:03:15.200 --> 00:03:21.080
which would be an entity for our artists table, in&nbsp;
the music database, that we've been working with.&nbsp;

00:03:21.080 --> 00:03:26.640
In this example, the annotation Entity,&nbsp;
describes this class as the Entity type.&nbsp;

00:03:26.640 --> 00:03:31.920
A framework implementing JPA, will&nbsp;
identify entities by this annotation.&nbsp;

00:03:31.920 --> 00:03:36.280
The annotation that follows next is&nbsp;
table, further describes the table name,&nbsp;&nbsp;

00:03:36.280 --> 00:03:40.360
so that is artists in this case.
Next the fields in this class&nbsp;&nbsp;

00:03:40.360 --> 00:03:45.000
also have annotations which describe&nbsp;
their database correlated information.&nbsp;

00:03:45.000 --> 00:03:50.360
So I have an Id, and that's the artist id.
I include the column annotation,&nbsp;&nbsp;

00:03:50.360 --> 00:03:56.120
which specifies the ID's column name.
Next, I describe the field, artist Name,&nbsp;&nbsp;

00:03:56.120 --> 00:03:59.960
as mapping to the column&nbsp;
name, artist underscore name.&nbsp;

00:03:59.960 --> 00:04:04.520
After this, I've declared a&nbsp;
list of albums, for this artist.&nbsp;

00:04:04.520 --> 00:04:08.680
Above this field, I specify&nbsp;
information about the relationship.&nbsp;

00:04:08.680 --> 00:04:13.080
I use the one to many annotation, then&nbsp;
the join column, with the joined id,&nbsp;&nbsp;

00:04:13.080 --> 00:04:18.400
so album underscore id.
The entity manager is&nbsp;&nbsp;

00:04:18.400 --> 00:04:22.760
implemented by the JPA Provider.
An entity can exist in a managed&nbsp;&nbsp;

00:04:22.760 --> 00:04:27.720
state, managed by the Entity Manager.
Or it can exist in a detached state,&nbsp;&nbsp;

00:04:27.720 --> 00:04:31.760
outside of an Entity Manager.
A detached entity can then be merged&nbsp;&nbsp;

00:04:31.760 --> 00:04:37.360
into an EntityManager, if a commit&nbsp;
is needed to a persistence layer..&nbsp;

00:04:37.360 --> 00:04:40.320
There are some key methods on the&nbsp;
EntityManager interface to know,&nbsp;&nbsp;

00:04:40.320 --> 00:04:44.760
that line up with the CRUD operations
The persist method makes a detached&nbsp;&nbsp;

00:04:44.760 --> 00:04:49.480
instance managed, and it's this instance's&nbsp;
state will get persisted on a commit..&nbsp;

00:04:49.480 --> 00:04:52.600
The find method searches for an&nbsp;
entity of the specified class using&nbsp;&nbsp;

00:04:52.600 --> 00:04:57.880
the primary key, in the persistent layer.
It returns an instance that will be managed,&nbsp;&nbsp;

00:04:57.880 --> 00:05:01.840
and automatically persisted.
If an entity is managed,&nbsp;&nbsp;

00:05:01.840 --> 00:05:06.680
updates will be propagated automatically&nbsp;
to the persistence layer, on a commit.&nbsp;

00:05:06.680 --> 00:05:11.560
If the entity is not yet managed, a merge&nbsp;
method will make the entity managed.&nbsp;

00:05:11.560 --> 00:05:15.760
The remove method removes the entity instance&nbsp;
from management, and executes a delete on the&nbsp;&nbsp;

00:05:15.760 --> 00:05:18.240
persistence layer.
I'll be walking&nbsp;&nbsp;

00:05:18.240 --> 00:05:26.080
through examples of these methods coming up.
The persistence context has multiple purposes.&nbsp;

00:05:26.080 --> 00:05:32.720
It tracks the lifecycle state of managed entities.&nbsp;
These states include new, managed, detached,&nbsp;&nbsp;

00:05:32.720 --> 00:05:38.600
and removed, reflecting any changes you make to&nbsp;
their properties. It synchronizes changes made to&nbsp;&nbsp;

00:05:38.600 --> 00:05:43.800
managed entities with the database. This happens&nbsp;
automatically when a transaction is committed&nbsp;&nbsp;

00:05:43.800 --> 00:05:49.720
or flushed, ensuring the database state reflects&nbsp;
the state of your in-memory objects. It performs&nbsp;&nbsp;

00:05:49.720 --> 00:05:55.400
identity management, ensuring unique entity&nbsp;
identity within a transaction. Even if you create&nbsp;&nbsp;

00:05:55.400 --> 00:06:00.400
duplicate objects with the same identifier, the&nbsp;
persistence context recognizes and manages them&nbsp;&nbsp;

00:06:00.400 --> 00:06:06.680
as a single entity. It acts as a cache, reducing&nbsp;
database roundtrips by keeping frequently accessed&nbsp;&nbsp;

00:06:06.680 --> 00:06:11.840
entities in memory, for faster retrieval.
The objective of this lecture and the ones that&nbsp;&nbsp;

00:06:11.840 --> 00:06:17.960
follow, aren't to give you a deep dive into JPA.
Instead, I want to give you a simple introduction&nbsp;&nbsp;

00:06:17.960 --> 00:06:22.160
to this architecture, which&nbsp;
is used by so many frameworks.&nbsp;

00:06:22.160 --> 00:06:29.520
Let's get back to some code, and start exploring&nbsp;
these concepts a little bit, in a concrete way.&nbsp;

00:06:29.520 --> 00:06:34.880
I've created a new project, called&nbsp;
JPA, with the usual Main class set up.&nbsp;

00:06:34.880 --> 00:06:38.712
Before I do anything, I need to include&nbsp;
some additional libraries in my project.&nbsp;

00:06:39.701 --> 00:06:41.748
So I'll go to Module Settings.

00:06:44.131 --> 00:06:45.632
I'll select Libraries.

00:06:46.459 --> 00:06:50.440
First, I'll need to add the jdbc&nbsp;
driver for MySQL, which I've done&nbsp;&nbsp;

00:06:50.440 --> 00:06:53.191
in several projects, so I'll quickly do this.

00:06:55.069 --> 00:06:58.880
I'll navigate to that jar file, and select it,

00:06:58.880 --> 00:07:04.000
and accept all the default settings there.
If you've updated Intelli J recently,&nbsp;&nbsp;

00:07:04.000 --> 00:07:08.440
you may get an additional dialog,
It's titled Detected Roots,&nbsp;&nbsp;

00:07:08.440 --> 00:07:14.040
and says Choose Roots, and for this you just want&nbsp;
to hit the OK button, assuming a root is selected,&nbsp;&nbsp;

00:07:14.040 --> 00:07:15.892
which it should be, by default.

00:07:20.052 --> 00:07:21.400
The next dialog lets me select

00:07:21.400 --> 00:07:27.800
which module it should be added to, and since&nbsp;
I've only got one option, I'll click ok on that.&nbsp;

00:07:27.800 --> 00:07:32.800
Next, I need the jakarta JPA module.&nbsp;
I could get this module from Maven,&nbsp;&nbsp;

00:07:32.800 --> 00:07:37.760
but I also need a JPA Provider.
For the provider, I'll use Hibernate,&nbsp;&nbsp;

00:07:37.760 --> 00:07:42.600
and that comes packaged with the JPA,&nbsp;
so I can just include that one module.&nbsp;

00:07:42.600 --> 00:07:46.920
I'll get this module from Maven.
In the next section of the course,&nbsp;&nbsp;

00:07:46.920 --> 00:07:51.120
I'll be talking more about Maven,&nbsp;
so just follow along with me here.&nbsp;

00:07:51.120 --> 00:07:58.040
I'll type in org.hibernate. ORM, and press enter.
I'll get this error but will give it a moment,&nbsp;&nbsp;

00:07:58.040 --> 00:08:02.280
and a list should popup.
Rather than scroll down and look for&nbsp;&nbsp;

00:08:02.280 --> 00:08:09.120
what I want, I can continue to type in this field,
so I'll add colon, hibernate, dash, core in this&nbsp;&nbsp;

00:08:09.120 --> 00:08:15.240
input field, after the org.hibernate.orm.
It's important that you don't have any&nbsp;&nbsp;

00:08:15.240 --> 00:08:19.120
spaces before or after the colon.
Now I'll see the versions of this&nbsp;&nbsp;

00:08:19.120 --> 00:08:24.560
module listed, and I want to make sure I get&nbsp;
one that's the latest version, 6 or higher.&nbsp;

00:08:24.560 --> 00:08:29.640
For me, at the time of this&nbsp;
recording, its 6.4.1 Final.&nbsp;

00:08:29.640 --> 00:08:34.160
I'll select that.
Another dialog pops up.&nbsp;

00:08:34.160 --> 00:08:45.120
I'll make sure transitive dependencies&nbsp;
is checked in that dialog, and click ok.&nbsp;

00:08:45.120 --> 00:08:49.400
Now, it's important to examine the classes in the&nbsp;
version you picked, to verify that you have the&nbsp;&nbsp;

00:08:49.400 --> 00:08:55.640
jakarta.persistence dash api in this set of&nbsp;
classes, and that it's at least version 3.1.&nbsp;

00:08:55.640 --> 00:08:59.480
In addition, you want to verify that the&nbsp;
module you pick has hibernate-core there,&nbsp;&nbsp;

00:08:59.480 --> 00:09:03.680
and it's at least version 6.
Make sure you apply these changes on this&nbsp;&nbsp;

00:09:03.680 --> 00:09:06.771
screen, by selecting the ok or apply button.

00:09:09.235 --> 00:09:10.760
If you aren't seeing jakarta's persistence

00:09:10.800 --> 00:09:14.960
3.1 jar there, you should try these&nbsp;
steps again, or alternately manually&nbsp;&nbsp;

00:09:14.960 --> 00:09:21.320
add jakarta's persistence api 3.1 or higher.
Since things change more than they stay the same,&nbsp;&nbsp;

00:09:21.320 --> 00:09:25.240
let me just quickly show you how&nbsp;
to add that module separately.&nbsp;

00:09:25.240 --> 00:09:29.160
If you've verified this package in your&nbsp;
module, you don't need to do this next step,&nbsp;&nbsp;

00:09:29.160 --> 00:09:33.840
and can skip adding this module.
Again, I'll open the module settings,&nbsp;&nbsp;

00:09:33.840 --> 00:09:41.040
with Libraries selected, and click the + button.
And select From Maven.&nbsp;

00:09:41.040 --> 00:09:46.120
I'll type jakarta.persistence colon in there.
I could hit enter here, which gives me that&nbsp;&nbsp;

00:09:46.120 --> 00:09:51.240
error, or optionally I can do a search.
When you press enter, it's expecting a&nbsp;&nbsp;

00:09:51.240 --> 00:09:58.120
fully qualified coordinate, or module identifier,&nbsp;
and in these cases, we're supplying only a part.&nbsp;

00:09:58.120 --> 00:10:03.000
The search is a bit more friendly, and&nbsp;
that's the search icon next to this field.&nbsp;

00:10:03.000 --> 00:10:07.360
Hitting that rather than enter, doesn't give&nbsp;
me an error, and it displays information about&nbsp;&nbsp;

00:10:07.360 --> 00:10:12.160
how many matches it found, and after&nbsp;
a slight pause, will display them.&nbsp;

00:10:12.160 --> 00:10:17.640
Now I see the different versions of this&nbsp;
package, and I'll pick the 3.1 point 0 version.&nbsp;

00:10:17.640 --> 00:10:20.880
You probably don't want to pick any&nbsp;
version with M or B in the suffix,&nbsp;&nbsp;

00:10:20.880 --> 00:10:25.920
these are milestone and beta versions,&nbsp;
which may not be the most stable versions.&nbsp;

00:10:25.920 --> 00:10:32.800
RC stands for release candidate, so again,&nbsp;
I'd just stick to one without those suffixes.&nbsp;

00:10:32.800 --> 00:10:37.080
This module has a single jar file in it and&nbsp;
you'll see that displayed in the classes list,&nbsp;&nbsp;

00:10:37.080 --> 00:10:38.225
after you add this.

00:10:41.254 --> 00:10:43.632
Again, click OK or apply.

00:10:44.520 --> 00:10:49.720
In my case, I don't need this jar file in my&nbsp;
dependencies twice, so I'll simply open module&nbsp;&nbsp;

00:10:49.720 --> 00:10:58.560
settings again to the Library section, and&nbsp;
remove this jakarta.persistence module here.&nbsp;

00:10:58.560 --> 00:11:04.960
Again, it's part of the hibernate module I&nbsp;
included, so for me, it's not necessary.&nbsp;

00:11:04.960 --> 00:11:09.160
The purpose of Maven is to help us sort&nbsp;
these dependencies out, but again, I'll&nbsp;&nbsp;

00:11:09.160 --> 00:11:13.960
cover that in a later section of the course.
Now that we've got the libraries we need,&nbsp;&nbsp;

00:11:13.960 --> 00:11:17.360
we can get back to coding.
I'll start with creating a&nbsp;&nbsp;

00:11:17.360 --> 00:11:22.880
couple of entities for the music database.
There are tools, including a Hibernate plugin&nbsp;&nbsp;

00:11:22.880 --> 00:11:28.480
for Intelli J, that will generate entities&nbsp;
for you, based on your database schema.&nbsp;

00:11:28.480 --> 00:11:33.640
This plugin's not available however, for&nbsp;
the community edition, which we're using.&nbsp;

00:11:33.640 --> 00:11:37.600
Since we only have three tables, I'll&nbsp;
create these manually, which is a good&nbsp;&nbsp;

00:11:37.600 --> 00:11:42.640
exercise anyway, as you're learning.
So first, I'll create the Artist,&nbsp;&nbsp;

00:11:42.640 --> 00:11:45.163
in the dev.lpa.music package.

00:11:49.787 --> 00:11:50.940
To make this an entity,

00:11:50.960 --> 00:11:56.120
I simply use the annotation, Entity.
Intelli J should be able to resolve&nbsp;&nbsp;

00:11:56.120 --> 00:12:01.480
this annotation, and include an import. For&nbsp;
me though, I have to select Entity by double&nbsp;&nbsp;

00:12:01.480 --> 00:12:05.240
clicking and it adds the import.
This is part of the package,&nbsp;&nbsp;

00:12:05.240 --> 00:12:11.560
jakarta.persistence, which is included in the&nbsp;
hibernate core package, as I mentioned before.&nbsp;

00:12:11.560 --> 00:12:16.360
If I hover over the entity annotation,&nbsp;
I can see how Intelli J resolved it.&nbsp;

00:12:16.360 --> 00:12:21.920
If you don't see jakarta.persistence, then you&nbsp;
should go back to the installation of the module.&nbsp;

00:12:21.920 --> 00:12:26.280
Specifically, you really don't&nbsp;
want to see javax.persistence.&nbsp;

00:12:26.280 --> 00:12:30.160
This jakarta.persistence contains all&nbsp;
the annotations, and the interfaces&nbsp;&nbsp;

00:12:30.160 --> 00:12:34.040
for the JPA specification.
An entity usually has a&nbsp;&nbsp;

00:12:34.040 --> 00:12:40.160
relationship to a table, so I'll set that up.
I'll add the Table annotation, after Entity,&nbsp;&nbsp;

00:12:40.160 --> 00:12:44.560
but before the class declaration. Here&nbsp;
I'll specify the name of the table&nbsp;&nbsp;

00:12:44.560 --> 00:12:48.720
in the music schema which is artists
You can see the import was not added&nbsp;&nbsp;

00:12:48.720 --> 00:12:53.840
automatically, so I'll just click it and&nbsp;
do an ALT-ENTER and ensure I choose the&nbsp;&nbsp;

00:12:53.840 --> 00:13:00.320
jakarta.persistence Table like this.
My artist table only has two columns,&nbsp;&nbsp;

00:13:00.320 --> 00:13:06.800
artist id and artist name, so I'll set up two&nbsp;
fields on this class, to represent those columns.&nbsp;

00:13:06.800 --> 00:13:12.320
I'll start with the annotation, Id. Every&nbsp;
database entity requires this on one field,&nbsp;&nbsp;

00:13:12.320 --> 00:13:18.280
which represents the primary key. I'll map the&nbsp;
field to the column name, artist underscore id,&nbsp;&nbsp;

00:13:18.280 --> 00:13:24.240
which is the primary key for artists. I'll fix&nbsp;
the imports in a bit. And here I'll have my&nbsp;&nbsp;

00:13:24.240 --> 00:13:31.280
declaration for the field name, so private int&nbsp;
artist id. And again, I'll map the next field,&nbsp;&nbsp;

00:13:31.280 --> 00:13:39.320
this time to the artist_name column. I'll declare&nbsp;
this field as a string, and call it artistName.&nbsp;

00:13:39.320 --> 00:13:44.240
As you saw, the imports for Id and&nbsp;
Column were added automatically for me.&nbsp;

00:13:44.240 --> 00:13:47.840
I need some constructors and getters&nbsp;
and setters, so I'll generate these,&nbsp;&nbsp;

00:13:47.840 --> 00:13:51.880
starting with the constructors.
All JPA entities are required to have&nbsp;&nbsp;

00:13:51.880 --> 00:13:58.720
a no args constructor, so I'll add that first.
I'll pick constructor from the Generate menu.&nbsp;

00:13:58.720 --> 00:14:05.200
I'll click on the select None button at&nbsp;
the bottom of this dialog, as the option.&nbsp;

00:14:05.200 --> 00:14:11.040
That generates my no args constructor.
I'll repeat this process for a second&nbsp;&nbsp;

00:14:11.040 --> 00:14:15.040
constructor, but in this case, I'll&nbsp;
select artist name in the dialog,&nbsp;&nbsp;

00:14:15.040 --> 00:14:18.920
and click OK to create a one argument constructor.&nbsp;

00:14:18.920 --> 00:14:23.240
That generates a constructor with the&nbsp;
artist name as the only parameter.&nbsp;

00:14:23.240 --> 00:14:28.200
I'll repeat this one last time, so again&nbsp;
picking constructor from the generate menu.&nbsp;

00:14:28.200 --> 00:14:34.120
In this case, I'll select both&nbsp;
fields, then click the ok button.&nbsp;

00:14:34.120 --> 00:14:38.080
That's my third and last&nbsp;
constructor for this class.&nbsp;

00:14:38.080 --> 00:14:43.160
Now, I'll add a getter and setter,&nbsp;
selecting that combo from the generate menu.&nbsp;

00:14:43.160 --> 00:14:48.040
I'll pick just the artist name, since&nbsp;
I don't need these methods for the id.&nbsp;

00:14:48.040 --> 00:14:52.600
Intelli J generates the getArtistName&nbsp;
and setArtistName methods for me.&nbsp;

00:14:52.600 --> 00:14:57.560
Finally, I'll include a toString method, and&nbsp;
again I'll generate that, using Alt Insert,&nbsp;&nbsp;

00:14:57.560 --> 00:15:03.840
and picking toString from the Generate Menu shown.
The template might be set to the JSON Builder&nbsp;&nbsp;

00:15:03.840 --> 00:15:07.640
template, from the last&nbsp;
challenge, as it was for me.&nbsp;

00:15:07.640 --> 00:15:12.480
I'll instead choose the String concat&nbsp;
template, from the select list here&nbsp;

00:15:12.480 --> 00:15:17.920
I'll select both fields in&nbsp;
the next dialog, and hit ok.&nbsp;

00:15:17.920 --> 00:15:22.840
And we are done.
I've created my first JPA Entity.&nbsp;

00:15:22.840 --> 00:15:27.280
It's really just an annotated pojo.
I'll close this video here,&nbsp;&nbsp;

00:15:27.280 --> 00:15:30.840
before it gets too long.
In the next video, we'll use this&nbsp;&nbsp;

00:15:30.840 --> 00:15:35.680
entity to communicate with the artist table in&nbsp;
the database, so I'll see you in that next video.
