WEBVTT
Kind: captions
Language: en

00:00:05.160 --> 00:00:10.680
In the last two videos, I walked you through a
couple of simple scenarios, using JPQL to retrieve

00:00:10.680 --> 00:00:16.160
targeted information, from the music database.
In this video, I'll do something similar,

00:00:16.160 --> 00:00:20.480
but I'll use the Criteria Builder.
The Criteria Builder interface

00:00:20.480 --> 00:00:25.880
describes a factory class, for creating
various type-safe query components.

00:00:25.880 --> 00:00:31.960
It provides methods for creating the different
parts of a JPA query, each described as an object,

00:00:31.960 --> 00:00:33.900
and not just part of a string.

00:00:35.525 --> 00:00:37.047
The Criteria Builder's methods

00:00:37.047 --> 00:00:42.640
are used to create specific instances, both
the criteria query object, and its parts,

00:00:42.640 --> 00:00:47.800
the specific criteria in other words,
that make up the definition of the query.

00:00:47.800 --> 00:00:52.600
A query in it's simplest form consists of a
command, as well as a source of some sort.

00:00:52.600 --> 00:00:57.720
A command might be select, update, or
delete, and a source in SQL is usually a

00:00:57.720 --> 00:01:01.755
table or view, whereas in JPQL it's an entity.

00:01:03.380 --> 00:01:05.727
A query may also have many other clauses and

00:01:05.727 --> 00:01:08.720
specifics, which define what needs to be done.

00:01:09.532 --> 00:01:12.067
The Criteria Builder provides all the building

00:01:12.067 --> 00:01:16.600
blocks, as Java Objects, to
fashion a specific query.

00:01:16.600 --> 00:01:21.680
It starts with the Criteria Query instance.
You can think of this as the scaffolding,

00:01:21.680 --> 00:01:26.800
in which everything else is going to be placed.
The scaffolding has specific slots, and these

00:01:26.800 --> 00:01:31.880
translate to methods on the Criteria Query.
The building blocks fall into one of four

00:01:31.880 --> 00:01:36.800
categories, which include the Predicate,
Expression, Selection, and Order types.

00:01:36.800 --> 00:01:41.440
The Criteria Builder isn't responsible for
executing a query, or even putting all the

00:01:41.440 --> 00:01:46.720
parts together, it is just responsible for
creating customizable components you'll need.

00:01:46.720 --> 00:01:51.360
The Criteria Query object will use the
building block types, in its design,

00:01:51.360 --> 00:01:53.535
to construct a specific query.

00:01:55.296 --> 00:01:58.458
The Criteria Query is a bit like scaffolding.

00:01:58.458 --> 00:02:02.200
And a bit similar to a String
Builder object, in that things get added,

00:02:02.200 --> 00:02:06.480
and the instance mutates and grows.
Unlike the String Builder though, the

00:02:06.480 --> 00:02:12.680
additions to the Criteria Query object can be of
multiple types, depending on the method selected.

00:02:12.680 --> 00:02:17.400
Pause the video here for just a moment, and
take a little time to familiarize yourself,

00:02:17.400 --> 00:02:21.000
with some of the methods on this class.
You'll notice that the methods on

00:02:21.000 --> 00:02:26.920
this class almost all represent specific
clauses or expressions, in a select query.

00:02:26.920 --> 00:02:32.440
You've got the select method, the from method,
a where method, as well as others like distinct,

00:02:32.440 --> 00:02:36.520
order by, having, group by, and so
on, which should be familiar terms for

00:02:36.520 --> 00:02:42.240
anyone who has written SQL queries.
Also notice, the arguments passed

00:02:42.240 --> 00:02:46.200
to these methods, which mostly consist
of the four types I mentioned already,

00:02:46.200 --> 00:02:50.160
and which are displayed here as well.
When you pass instances of these types to

00:02:50.160 --> 00:02:57.360
methods, you'll be using a CriteriaBuilder factory
method, to get specific instances of these types.

00:02:57.360 --> 00:03:00.440
A Predicate represents a
condition in a WHERE clause.

00:03:00.760 --> 00:03:05.320
An Expression represents a computed value.
This can be a mathematical expression,

00:03:05.320 --> 00:03:10.840
a function call, or a field reference.
An Order is used to represent sorting

00:03:10.840 --> 00:03:15.800
criteria for the ORDER BY clause.
A Selection represents an attribute,

00:03:15.800 --> 00:03:22.400
expression, or result, used to define
the selectable output of the query.

00:03:22.400 --> 00:03:27.040
Finally, notice the from, method on this class.
This method is different from the

00:03:27.040 --> 00:03:31.800
rest and returns a root instance.
The Root is a special type, and it's the bridge

00:03:31.800 --> 00:03:37.680
between the criteria query and your entity.
It's the source of the query's data.

00:03:37.680 --> 00:03:42.040
It's more common to have just one root,
but there's support for multiples.

00:03:42.040 --> 00:03:46.080
I also want you to see that other than the
from method, all of these methods return

00:03:46.080 --> 00:03:50.360
an instance of Criteria Query.
Like the String Builder object,

00:03:50.360 --> 00:03:56.840
the Criteria Query object is mutable, but
each method returns a reference to itself.

00:03:56.840 --> 00:04:00.360
This means you can optionally chain these
methods together, which provides the

00:04:00.360 --> 00:04:07.160
advantage of more concise and readable code.
This slide summarizes how to use the Criteria

00:04:07.160 --> 00:04:13.280
Builder and Criteria Query types, to
execute queries using JPA entities.

00:04:13.280 --> 00:04:16.520
First, you get an instance of
Criteria Builder, using the get

00:04:16.520 --> 00:04:21.720
Criteria Builder method on an Entity Manager.
Once you have a Criteria Builder, you then get

00:04:21.720 --> 00:04:26.920
a Criteria Query instance from that.
You'll specify the root, or entity

00:04:26.920 --> 00:04:32.080
that the query will select its data from.
You then specify additional information, or the

00:04:32.080 --> 00:04:39.200
details, about the query, like a where clause,
an order by, or Group By clause for example.

00:04:39.200 --> 00:04:44.520
You'll invoke various methods on Criteria
Query, while using the Criteria Builder to

00:04:44.520 --> 00:04:48.880
manufacture the appropriate pieces,
which get passed as arguments.

00:04:48.880 --> 00:04:53.680
Once you've constructed the query's
criteria, you create an executable query,

00:04:53.680 --> 00:04:59.200
like we did with the JPQL Typed Query, by
calling create Query on the entity manager.

00:04:59.200 --> 00:05:05.040
This method returns a query instance, which is
different, from the criteria query instance.

00:05:05.040 --> 00:05:10.800
You execute the query and retrieve results, using
one of the several methods on the query instance.

00:05:10.800 --> 00:05:17.320
You'll remember these include get Result List, get
Result Stream, and get Single Result, for example.

00:05:17.320 --> 00:05:21.320
Now that you've got a basic understanding
of what this process consists of,

00:05:21.320 --> 00:05:23.314
let's work through it in some code.

00:05:25.403 --> 00:05:28.567
Getting back to my JPA project, and the Main Query

00:05:28.567 --> 00:05:33.600
class, I'll add another private static method.
This time, I'll return a Stream of Artist

00:05:33.600 --> 00:05:38.240
instances. I'll call this method get
Artists Builder, and it's parameters

00:05:38.240 --> 00:05:43.040
will be the same as the earlier method,
so an Entity Manager first, and then a String,

00:05:43.040 --> 00:05:48.800
I'll again call matched Value. I start by
creating a CriteriaBuilder variable, which

00:05:48.800 --> 00:05:55.040
I'll call builder. I get an instance of a criteria
builder, from entity manager, using the method get

00:05:55.040 --> 00:06:01.960
Criteria Builder. Next, I'll set up a criteria
query variable, with a type argument of Artist. I

00:06:01.960 --> 00:06:11.040
use the criteria builder method, create Query, to
get an instance, and I pass that the Artist class.

00:06:11.040 --> 00:06:15.200
Next, I need something called a query root.
This represents the starting point for

00:06:15.200 --> 00:06:20.960
constructing a query against a data
set, represented as an entity class.

00:06:20.960 --> 00:06:26.400
So this has the Root type, with Artist as
the type argument, I'll just call it root,

00:06:26.400 --> 00:06:33.480
and I can get this using criteria Query.from,
and passing Artist.class to that method.

00:06:33.480 --> 00:06:36.920
You can think of the root
as the from clause, in JPQL.

00:06:36.920 --> 00:06:41.480
So if I add nothing to the root, the
entire table associated with this entity

00:06:41.480 --> 00:06:46.680
is the data set, that will be operated on.
Next, I define the operation I want to execute

00:06:46.680 --> 00:06:54.080
on my criteria Query object, which in this case
is select. I pass it the root instance. Finally,

00:06:54.080 --> 00:07:01.000
I can create the query, and call getResultStream.
Now, moving back up to the main method,

00:07:01.000 --> 00:07:04.440
I'll insert the next segment of
code, before the commented out code,

00:07:04.440 --> 00:07:07.960
that's currently in the try block.
I'll include a separator line so

00:07:07.960 --> 00:07:13.680
I can distinguish the output from the earlier
method call. I'll include a Stream of Artists,

00:07:13.680 --> 00:07:18.840
setting that to the value I get back from my new
method, get Artists Builder. I'll pass that the

00:07:18.840 --> 00:07:25.040
entity manager variable, and for now an empty
string literal. Because I get a stream back,

00:07:25.040 --> 00:07:30.240
I can use stream operations to manipulate the
data further. I'm going to limit the results to

00:07:30.240 --> 00:07:36.440
10. A more refined query would have brought less
data back, which is a much better approach. I'm

00:07:36.440 --> 00:07:41.840
really just including it here now, so I don't have
to look at 200 lines of output. Next, I'll collect

00:07:41.840 --> 00:07:48.480
the data into a map, using Collectors.toMap.
The first argument specifies the function, to

00:07:48.480 --> 00:07:54.480
get the key, so it's keyed by the artist name. The
next argument, is the function to get the value,

00:07:54.480 --> 00:07:59.840
so that's just the number of albums. Next, I need
to specify a merge function, and I'll just use the

00:07:59.840 --> 00:08:06.520
method reference for Integer sum there. I want a
tree map back, because it'll be ordered. Finally,

00:08:06.520 --> 00:08:12.520
I want to print the artist name, and the
number of albums that artist has in the data.

00:08:12.520 --> 00:08:18.240
I've no idea what happened with the
formatting. Let me reformat the code.

00:08:18.240 --> 00:08:29.440
For some reason Tree Map did not
get imported. I'll add it manually.

00:08:31.452 --> 00:08:33.233
All right, I fixed it.

00:08:33.233 --> 00:08:35.231
I'll run this code.

00:08:36.570 --> 00:08:39.680
And now you see 10 artists, in artist name order,

00:08:39.680 --> 00:08:44.440
and the number of albums each of these has.
This just printed the first 10 artists it got,

00:08:44.440 --> 00:08:48.800
because of the limit operation.
The artists weren't ordered, in the stream,

00:08:48.800 --> 00:08:52.720
though they're ordered here.
I'll next refine the query,

00:08:52.720 --> 00:08:59.440
to include an order by clause, so I'll go
back to the get Artists Builder method.

00:09:00.280 --> 00:09:04.960
I start with criteria query, and call
order by, passing another factory object,

00:09:04.960 --> 00:09:10.440
which I get by calling a method, A S C, which
stands for ascending order. This method returns

00:09:10.440 --> 00:09:17.160
an Order instance. I pass root.get artist
name in there, which defines how to sort.

00:09:17.160 --> 00:09:21.720
I'll rerun my code.
I've got a different set of artists,

00:09:21.720 --> 00:09:25.760
so the first 10 alphabetically,
starting with one thousand maniacs.

00:09:25.760 --> 00:09:29.360
I'm really still getting all 200 back,
so I'll next include a where clause.

00:09:30.040 --> 00:09:34.240
Getting back to my get Artists Builder
method, I'll insert another statement,

00:09:34.240 --> 00:09:38.920
between the where method, and the order by method.
These don't really have to be in this order,

00:09:38.920 --> 00:09:43.040
but I'll just keep them in the
logical order of a SQL statement.

00:09:43.040 --> 00:09:48.600
I start by invoking the where method on criteria
query, I need to pass that a Predicate instance,

00:09:48.600 --> 00:09:52.000
which I can get from many methods on
the CriteriaBuilder, but in this case

00:09:52.000 --> 00:09:58.960
I want to use the like method, passing that
root.get artistname, and the matchedValue.

00:09:58.960 --> 00:10:03.760
Next, I'll scroll back up to the main method,
where I'll next change the empty string literal,

00:10:03.760 --> 00:10:09.920
replacing that with the text, B L, percent sign.
This means I want to get only artists whose names

00:10:09.920 --> 00:10:14.840
start with B L.
I'll run this.

00:10:14.840 --> 00:10:18.280
I get matching records, so my where
clause worked, and I'm only getting

00:10:18.280 --> 00:10:22.760
artists whose names start with B L.
Before I move on, I'll just change the

00:10:22.760 --> 00:10:25.870
get Artists Builder method, one last time.

00:10:27.244 --> 00:10:30.269
The Criteria Query is a mutable object,

00:10:30.280 --> 00:10:34.360
which is why I don't need to reassign the
instance, on each of these method calls.

00:10:34.360 --> 00:10:36.960
Each method outputs a reference
to itself, which means I can

00:10:36.960 --> 00:10:39.481
chain methods together, so I'll do that.

00:10:48.515 --> 00:10:53.760
This creates a chain of three methods.
I'll use IntelliJ to reformat this code.

00:10:53.760 --> 00:10:56.400
You can see this reads somewhat
like stream operations.

00:10:56.400 --> 00:11:01.080
This is a lot easier to read in my opinion.
I'll run that, and confirm I get the same

00:11:01.080 --> 00:11:02.438
results as before.

00:11:04.392 --> 00:11:05.726
And I do.

00:11:05.726 --> 00:11:10.120
In the interest of time, I won't be covering
how to do joins in a Criteria Builder query

00:11:10.120 --> 00:11:14.360
here because I want to quickly show
you how to execute a Native Query.

00:11:14.360 --> 00:11:16.800
Again, I'm not applying the
same standard to teaching you

00:11:16.800 --> 00:11:23.280
JPA as I have been Java's core functionality.
This foray into JPA was a bit of a courtesy,

00:11:23.280 --> 00:11:27.800
since it's increasingly becoming an
industry standard, in some form or another.

00:11:27.800 --> 00:11:33.240
If you're curious about joins, be sure to see
the Bonus section of the challenge that follows.

00:11:33.240 --> 00:11:39.240
Finally, I'll quickly demonstrate one last way to
query using JPA, and that's by executing a native

00:11:39.240 --> 00:11:44.080
query, with the entity manager.
I'll add another method.

00:11:44.080 --> 00:11:50.040
This is private, static, returns a Stream of
Artist, and it'll be called get Artists SQL.

00:11:50.040 --> 00:11:54.240
This method will have the same parameters
as the others, so an entity manager,

00:11:54.240 --> 00:11:59.240
and a string named matched value.
I'll set up a local variable, called query,

00:11:59.760 --> 00:12:05.240
the result of calling create Native Query on
the entity manager argument. This method takes

00:12:05.240 --> 00:12:11.840
a string, which is native SQL, but with one minor
exception. This string can contain placeholders,

00:12:11.840 --> 00:12:16.920
either named or numeric, which I'll use here.
I'll select from the table, and just to make

00:12:16.920 --> 00:12:23.360
it clearer, I'll include the schema, so select,
star from music dot artists where artist_name,

00:12:23.360 --> 00:12:29.480
and this is the column name now, not the entity
name, like, question mark 1. I still pass the

00:12:29.480 --> 00:12:35.160
Artist class as the second argument, because the
JPA Provider will instantiate artist instances

00:12:35.160 --> 00:12:41.080
from the data, through JPA magic. I also still
set the parameter, and that's parameter 1,

00:12:41.080 --> 00:12:48.320
that'll get set to the matched value.
Finally, I'll return the results as a stream.

00:12:48.320 --> 00:12:52.920
Going back up to my main method, I'll change
the code, that was calling get Artists Builder,

00:12:52.920 --> 00:12:57.880
and replace it with a call to
this method, so get Artists SQL.

00:12:57.880 --> 00:12:58.848
I'll run that,

00:13:01.634 --> 00:13:03.800
and you can see,
that again produces the same result

00:13:03.800 --> 00:13:08.920
as the Criteria Builder code, when it
didn't include the order by clause.

00:13:08.920 --> 00:13:14.560
Which type of query you use, is
dependent on a lot of different factors.

00:13:14.560 --> 00:13:19.400
This slide summarizes the three types
of queries you can execute, using JPA.

00:13:19.400 --> 00:13:23.320
The Native Query Executes
native SQL queries directly.

00:13:23.320 --> 00:13:28.480
This gives you full control over SQL syntax.
It allows for performance optimizations for

00:13:28.480 --> 00:13:33.640
specific databases, and gives you
access to vendor specific features.

00:13:33.640 --> 00:13:40.000
The Criteria Builder Query lets you build
queries programmatically using Java objects.

00:13:40.000 --> 00:13:43.000
It's type safe, includes compile time checking,

00:13:43.000 --> 00:13:48.960
and allows for dynamic query construction.
The JPQL query uses a SQL like syntax,

00:13:48.960 --> 00:13:54.320
which is tailored to JPA Entities. It's
portable across JPA implementations.

00:13:54.320 --> 00:13:59.200
As you saw, it hides database implementation
details, and is a more intuitive method for

00:13:59.200 --> 00:14:03.200
anyone with SQL experience.
Ok, so this video ends the

00:14:03.200 --> 00:14:08.520
introduction to JPA, and is the end
of the Database section of the course.

00:14:08.520 --> 00:14:11.440
In the next video, I've got
a JPA challenge for you.

00:14:11.440 --> 00:14:15.920
Keep this project open, your challenge
will use the entities and configuration

00:14:15.920 --> 00:14:19.800
that already exist in this project.
I'll see you in that next video.
