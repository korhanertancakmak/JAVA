WEBVTT
Kind: captions
Language: en

00:00:05.360 --> 00:00:09.800
In this challenge, you'll be using My SQL
Workbench, to verify that the changes you

00:00:09.800 --> 00:00:14.760
make in Java, get persisted correctly.
There is one change you'll probably need

00:00:14.760 --> 00:00:18.433
to make though, to the settings
in My SQL Workbench to do this.


00:00:19.280 --> 00:00:23.160
My SQL Workbench has something
called connection caching,


00:00:23.160 --> 00:00:26.960
This means data is cached and not
refreshed immediately from persisted data.


00:00:27.760 --> 00:00:31.534
I'll show you how to configure it, to
make the refresh interval much shorter.


00:00:32.240 --> 00:00:37.233
This'll let you see the changes made in your
app, reflected immediately in MySQL Workbench.


00:00:38.080 --> 00:00:41.247
Open MySQL Workbench, to
your development session.


00:00:42.000 --> 00:00:47.016
Click on Edit, then Preferences.
This will bring up a dialog.


00:00:47.840 --> 00:00:52.760
Select SQL Editor on the left pane.
In the right panel, there's a section

00:00:52.760 --> 00:00:59.280
called MySQL session, with three entries.
The second one, is the read time out interval,

00:00:59.280 --> 00:01:03.059
and the one you want to change.
Set this to 1 second.


00:01:04.000 --> 00:01:08.520
Click ok, and now, as you're working on
this challenge, you can jump over to SQL

00:01:08.520 --> 00:01:14.903
Workbench, to test your results.
For your first JDBC Challenge,


00:01:15.680 --> 00:01:19.600
I want you to Write the Java code that
inserts an Order, and at least two Order

00:01:19.600 --> 00:01:26.240
details into your database. This should be
done in a transaction. Use MySQL Workbench

00:01:26.240 --> 00:01:31.830
to confirm your inserts worked. Write Code that
deletes an Order and its order details.

00:01:32.630 --> 00:01:36.080
Again, use MySQL Workbench to confirm your order and it's

00:01:36.080 --> 00:01:40.960
line items, were actually deleted.
I've included the date time format,

00:01:40.960 --> 00:01:43.274
that MySQL expects this field to be in.


00:01:44.027 --> 00:01:46.040
Ok, so go give that a try.


00:01:46.840 --> 00:01:51.129
Pause the video here, and go away and work
on that challenge, and see how you do.


00:01:52.000 --> 00:01:56.795
When you're done, or you get stuck, come back,
and we'll walk through my solution together.


00:02:00.160 --> 00:02:03.216
Welcome Back.
So how did you do?


00:02:04.040 --> 00:02:09.626
Were you able to change the code, to insert the
order and order details, in a single transaction?


00:02:10.520 --> 00:02:14.127
Did you add some data in both
tables, and then delete that data?


00:02:15.000 --> 00:02:20.289
Ok, so let's get started.
Here I am back in My SQL Workbench.


00:02:21.160 --> 00:02:26.480
Here I can see the storefront schema.
I'll leave the work bench open, coming back to it,

00:02:26.480 --> 00:02:31.743
to verify the data as I run my code in Java.
I'll get back to IntelliJ.


00:02:32.520 --> 00:02:37.009
I've got the JDBC Challenges project open,
where we left off in the last video.


00:02:37.880 --> 00:02:43.280
I'll create a new method, called add Order.
I'll make this private, static, and it

00:02:43.280 --> 00:02:47.332
returns an int, which will be the auto
incremented id I get back from MySQL.


00:02:48.320 --> 00:02:51.600
This method will take a connection,
and a String array, which will be

00:02:51.600 --> 00:02:58.200
the item descriptions, of the order details.
I'll start by declaring an order id variable,

00:02:58.200 --> 00:03:03.960
and initialize that to minus 1. I'll set up
my insert SQL statement, which is INSERT INTO

00:03:03.960 --> 00:03:10.511
storefront.order, followed by a list of column
names in parens. In this case I only need order date.

00:03:11.381 --> 00:03:17.640
After that, we specify VALUES, and another
set of parentheses. I'll surround my format string

00:03:17.640 --> 00:03:24.520
specifier with single quotes. The insert for the
storefront.order_details starts out similarly,

00:03:24.520 --> 00:03:31.440
so insert into storefront.order details in
this case. I'll define two columns, order_id,

00:03:31.440 --> 00:03:36.124
and item description, and two specifiers in this
string, an integer and a string.

00:03:37.089 --> 00:03:41.976
For the string,I'll use enquoteLiteral in my code that formats
it, so I'll leave out the single quotes here.

00:03:42.800 --> 00:03:49.280
I'll be returning order id from this method.
Next, I want to get the order date. I'll start

00:03:49.280 --> 00:03:54.520
with a DateTimeFormatter object. I can create
a Pattern, and I'll use the one I showed you on

00:03:54.520 --> 00:04:00.520
the challenge slide. I'll get the current
date and time, using local date time.now,

00:04:00.520 --> 00:04:06.800
and I'll chain the format method to that, passing
it my date time formatter variable. I'll print that out.

00:04:09.059 --> 00:04:14.614
I'll use this string, to populate the
insert order statement. I'll print that out too.


00:04:17.155 --> 00:04:21.800
Now, I could have used date time specifiers
in my formatted string, as an alternative to

00:04:21.800 --> 00:04:25.640
using the DateTimeFormatter.
In fact, let me just review

00:04:25.640 --> 00:04:29.480
what that would look like.
The insert starts out the same way,

00:04:29.480 --> 00:04:31.837
But the specifiers are a lot more cryptic.

00:04:34.214 --> 00:04:39.344
The 1 dollar sign in both cases means I can just pass a single date time variable for both of these values.

00:04:40.309 --> 00:04:46.361
The tF will print the date in the format y y y y, dash, m m, dash, d d.

00:04:47.279 --> 00:04:51.320
In the second specifier lowercase t, uppercase T,

00:04:51.320 --> 00:04:54.595
is the key to the time, being printed in the
format we want.

00:04:55.513 --> 00:04:58.074
I'll print this out usingLocalDateTime now as the argument.



00:05:02.287 --> 00:05:03.746
So this is an alternative.

00:05:04.640 --> 00:05:08.280
I'll run this code, since nothing will
get inserted yet, so you can see what

00:05:08.280 --> 00:05:12.520
this output looks like right now.
I'll jump back up to the main method,

00:05:12.520 --> 00:05:18.600
and make a call to my new add Order method.
I'll pass that the connection, and an array of

00:05:18.600 --> 00:05:23.520
strings, and I'll just use clothing in my
store front order, so my items are shoes,

00:05:23.520 --> 00:05:31.965
shirt, and socks. I'll assign the id I get back,
to the newOrder variable. and I'll print the new order id out.

00:05:34.342 --> 00:05:35.381
I'll run this.


00:05:37.240 --> 00:05:41.546
You can see the formatted date, using date
time formatter, which gave us a string.


00:05:42.440 --> 00:05:47.162
I used that string as an argument to the percent
s specifier, in my first insert order string.


00:05:48.080 --> 00:05:52.360
In the second example, I used date
time specifiers instead or percent t,

00:05:52.360 --> 00:05:57.456
and you can see both give me the same result.
Now let's actually use this insert method.


00:05:58.280 --> 00:06:02.369
I'll get back to the add Order method,
and set up my try with resources block.


00:06:05.640 --> 00:06:11.680
I'll wrap a new statement in this
try. Since we need a transaction,

00:06:11.680 --> 00:06:18.200
I'll set autocommit to false. I'll set up a
variable, inserts, then call executeUpdate,

00:06:18.200 --> 00:06:22.760
passing that my formatted string, and since
I want the generated key back, I can pass

00:06:22.760 --> 00:06:30.080
Statement dot return GENERATED KEYS as the second
argument. I'll call commit after this. And then

00:06:30.080 --> 00:06:37.278
set autocommit to true. In the catch clause, If I
get an exception, I want to roll the transaction back.

00:06:38.196 --> 00:06:43.480
Then I'll throw a runtime exception.
Notice that I've got an error on rollback,

00:06:43.480 --> 00:06:47.400
and that's because that throws an SQL
Exception too, and I need to handle it.


00:06:48.200 --> 00:06:51.525
I'll hover over that and select,
add exception to method signature.


00:06:59.786 --> 00:07:03.720
I'm not done yet, because I still have
to insert the order detail records.


00:07:05.320 --> 00:07:09.880
If I get a one back from inserting the order,
I know my order was added successfully,

00:07:09.880 --> 00:07:15.840
and only in this case, do I want to proceed. So
next, I need to get the generated key back from

00:07:15.840 --> 00:07:19.480
the insert order statement, and don't
forget that's retrieved by calling get

00:07:19.480 --> 00:07:26.240
Generated Keys. That returns a result set.
The first record in that result set, should

00:07:26.240 --> 00:07:34.480
have the key I want. The key will be at index
1. I'll set up another local variable, count,

00:07:34.480 --> 00:07:39.640
which I'll use to test how many detail items get
inserted. I'll loop through the items passed to

00:07:39.640 --> 00:07:45.000
this method. I'll format my string, using the
order id as the first argument.

00:07:46.028 --> 00:07:49.800
Here, I'll enquote the item string, using statement.enquote
literal.

00:07:50.788 --> 00:07:54.271
I'll call statement.executeUpdate,with this formatted string,

00:07:54.271 --> 00:07:58.080
returning the result back to my inserts variable. I'll add

00:07:58.080 --> 00:08:04.160
the value in inserts to my count variable.
If we get an exception saving the records,

00:08:04.160 --> 00:08:07.666
the data will be rolled back,
and a runtime exception thrown.


00:08:08.560 --> 00:08:12.680
But some database problems are silent,
meaning we may not get an exception,

00:08:12.680 --> 00:08:17.287
but something may not go as we expected, because
of problems with the logic in our queries.


00:08:18.040 --> 00:08:23.160
I'll add an additional test, in this code, to make
sure the results are what I expected them to be.


00:08:23.960 --> 00:08:27.800
I'll check if the value in count, or
the records inserted, is the same as

00:08:27.800 --> 00:08:33.654
the number of items passed to this method.
If it's not, I'll set order Id back to -1.

00:08:34.360 --> 00:08:35.825
And I'll print out the issue.

00:08:38.578 --> 00:08:40.578
I'll roll back the transaction if this happens.

00:08:41.661 --> 00:08:43.911
I'll wrap an else statement around the commit statement



00:08:48.100 --> 00:08:51.159
Ok, time to test this out, so I'll run this code.

00:08:53.160 --> 00:08:57.343
I see the two insert strings again,
but now I see new order equals 1.


00:08:58.120 --> 00:09:02.277
That's a good sign.
I'll open up MySQL Workbench.


00:09:04.960 --> 00:09:08.757
I'll click on the order table, and select
the grid or spreadsheet like icon.


00:09:10.240 --> 00:09:13.840
This will open an SQL editor pane
showing an executed select statement,

00:09:13.840 --> 00:09:18.710
with a result grid below, so you should see
order 1, with the order date listed there.


00:09:19.440 --> 00:09:23.209
I'll do the same for order details,
clicking the table like icon there.


00:09:24.080 --> 00:09:29.120
Here I can see all three of the order details
listed, associated with order 1, so that's it.


00:09:30.040 --> 00:09:34.489
Hopefully, you were able to do that, and you
figured out how to persist some data of your own.


00:09:35.360 --> 00:09:39.656
The second part of the challenge was to delete
an order, which includes it's line items.


00:09:40.480 --> 00:09:44.480
Getting back to IntelliJ, and
the JDBC Challenges project,

00:09:44.480 --> 00:09:48.586
I'll add a new method to do this, and I'll
insert this method after the addOrder method.


00:09:49.480 --> 00:09:53.470
This will be private, static,
void, and called delete Order.


00:09:54.200 --> 00:09:58.353
It'll take a connection, and the
order id, of the order to be deleted.


00:09:59.200 --> 00:10:04.640
I'll start with a formatted string, so Delete
from storefront.order, where order id equals,

00:10:04.640 --> 00:10:08.774
percent d. I'll format that, using the
orderId.

00:10:10.916 --> 00:10:13.457
I'll get a new statement in a try with resources block.

00:10:14.906 --> 00:10:19.490
I'll set up a variable called deleteRecords, and assign that the value of executeUpdate.

00:10:20.431 --> 00:10:25.840
I'll pass that, my deleteQuery
string. I'll print how many records got deleted.

00:10:26.640 --> 00:10:32.526
That should be one in every case. If I get an
exception, I'll throw a runtime exception.


00:10:36.080 --> 00:10:40.720
Getting back to the main method, I'll comment out
the add order code, and the println below that.


00:10:43.120 --> 00:10:49.303
I'll make a call to the delete method before that
code. I want to delete order id 1, in this case.


00:10:50.880 --> 00:10:56.666
I'll run this code.
The output says one record was deleted.


00:10:57.560 --> 00:11:02.339
I'll verify the results in MySQL WorkBench,
by re-executing the select statements.


00:11:03.280 --> 00:11:11.830
First on Order, and the result grid has no data.
I'll do the same on Order details.


00:11:14.654 --> 00:11:17.746
You can see I no longer have either
the order or the order detail records.


00:11:18.640 --> 00:11:23.360
Because of the cascade delete, defined in the
order detail table, I didn't actually have to

00:11:23.360 --> 00:11:28.960
include the delete order details code in Java.
This was optional for this scenario.


00:11:29.640 --> 00:11:32.875
Maybe you did code this, and
included it in a transaction.


00:11:33.840 --> 00:11:39.125
This is a valid solution as well.
I'll change my code a little, to do it that way.


00:11:40.160 --> 00:11:42.936
First, I'll uncomment the code
that creates a new order,


00:11:43.760 --> 00:11:50.731
and re run my code, so I have an order to delete.
This will set up order number 2, as you can see.


00:11:54.520 --> 00:11:57.402
I'll change the number from
1 to 2 in the deleteOrder.


00:11:58.320 --> 00:12:01.689
Next, I'll start by adding the
transaction code to my delete method.


00:12:04.560 --> 00:12:07.002
So first, I'll set auto commit to false.


00:12:09.520 --> 00:12:12.282
I'll call commit as the last
statement in the try block.


00:12:14.800 --> 00:12:21.120
I'll execute a roll back if I get an exception.
I'll again over hover the error I get on rollback,

00:12:21.120 --> 00:12:24.557
and select to have the SQL exception
added to the methods' throw clause.


00:12:28.040 --> 00:12:32.449
I'll add a finally clause in this case, because
I am throwing an exception in the catch clause.


00:12:33.438 --> 00:12:35.986
In either case I want to set
auto commit back to true.


00:12:36.880 --> 00:12:39.814
Putting that in a finally clause
ensures it always happens.


00:12:41.320 --> 00:12:44.240
Now, I'm going to make the delete
Order string more generic, and put

00:12:44.240 --> 00:12:48.400
a place holder in for the table name.
I'll change the name of the variable

00:12:48.400 --> 00:12:52.880
deleteQuery to parentQuery.
Then, I'll pass the table name,

00:12:52.880 --> 00:12:55.846
storefront.order, as the first argument here.


00:12:57.682 --> 00:13:01.683
Next, I'll create a childQuery, using the
same formattable string,

00:13:01.683 --> 00:13:04.160
this time passing the order details table,

00:13:04.160 --> 00:13:10.776
and I'll still delete by order id, Remember, the
child table has this id in it as a foreign key.


00:13:11.600 --> 00:13:15.000
I'll change the name of the query in
the execute update to be child query.


00:13:16.840 --> 00:13:20.289
I'll change my print statement to say
how many child records were printed.


00:13:21.560 --> 00:13:25.110
Now, I just need to add the code,
to delete the parent record.


00:13:25.840 --> 00:13:31.228
I'll executeUpdate on the parentQuery and return
results to the same variable, deleteRecords.

00:13:32.146 --> 00:13:37.200
Again, it's possible something could go amiss,
and not throw an exception, so I want to confirm

00:13:37.200 --> 00:13:43.910
one and only one order is deleted in this case.
I'll print that my order was successfully deleted.

00:13:45.440 --> 00:13:50.600
I'll include an else statement, and rollback if
my result wasn't one. I probably should have a

00:13:50.600 --> 00:13:56.600
statement printed here too, but you get the gist.
Before I run this, I'll comment out the code that

00:13:56.600 --> 00:13:58.147
adds a new order.



00:14:02.571 --> 00:14:04.147
Ok, I'll run this.

00:14:06.360 --> 00:14:11.418
I'll see that three child records were deleted,
and then order 2 was successfully deleted.


00:14:13.960 --> 00:14:19.160
I'll pop back over to MySQL Workbench, and
re-execute the queries, that were generated,

00:14:19.160 --> 00:14:24.527
when I displayed the table results. These
are currently showing as no data from last time.

00:14:25.539 --> 00:14:29.736
Remember we have created records again
and deleted them, before coming back here.


00:14:30.560 --> 00:14:37.320
I'll start with Order, and running that select
again, In the result grid below, I should have

00:14:37.320 --> 00:14:43.480
no data again, so I know this code worked.
I'll do the same for order_details, opening that

00:14:43.480 --> 00:14:50.000
tab, and executing that select query again.
And I get no data, so that's good.


00:14:50.840 --> 00:14:55.979
So Should you manually delete child records in
your Java code, or depend on cascade deletion?


00:14:56.920 --> 00:15:00.449
The answer to that question,
is as usual, it depends.


00:15:01.320 --> 00:15:03.320
If you're trying to be database agnostic,

00:15:03.320 --> 00:15:07.602
meaning your application is going to be deployed
in many environments with different databases.


00:15:08.520 --> 00:15:12.880
In this scenario, You'll probably be working
with varying degrees of database support,

00:15:12.880 --> 00:15:17.080
so then maybe you'd manually code the delete
child records, and you'd have confidence your

00:15:17.080 --> 00:15:22.120
code is always cleaning up the child records,
regardless of how the database is configured.


00:15:22.920 --> 00:15:27.680
Doing this might be simpler, than having to
publish requirements, on how the database needs

00:15:27.680 --> 00:15:33.840
to be set up, with cascade deletes implemented.
If you're deleting a large amount of data,

00:15:33.840 --> 00:15:38.000
it's probably more efficient to take
advantage of the table's cascade deletes,

00:15:38.000 --> 00:15:43.800
done on the database server's implementation.
All the major RDBMS vendors support cascade

00:15:43.800 --> 00:15:49.157
deletes, so that's a positive, but there may be
some vendors or lightweight RDBMS's that don't.


00:15:50.099 --> 00:15:56.120
Also, don't forget your JDBC backend could
even be files, like csv or jayson files,

00:15:56.120 --> 00:16:01.259
so in that case, you'd want to implement the
delete order_detail functionality yourself.


00:16:02.600 --> 00:16:08.000
In the delete order detail code, you can
see I parameterized the SQL statement,

00:16:08.000 --> 00:16:11.840
with the item description.
Ultimately though, I passed

00:16:11.840 --> 00:16:17.040
a static string to the executeUpdate method.
In the next video, I'll show you an alternative

00:16:17.040 --> 00:16:20.776
for parameterized SQL, in the
form of a Prepared Statement.
