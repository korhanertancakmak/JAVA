WEBVTT
Kind: captions
Language: en

00:00:05.480 --> 00:00:10.680
In the last video, I showed you how to execute
a procedure, stored on the database server, from

00:00:10.680 --> 00:00:16.320
Java using JDBC, and the Callable Statement.
This is often a preferred approach,

00:00:16.320 --> 00:00:21.720
for many enterprise organizations.
In the last example, we passed a set of

00:00:21.720 --> 00:00:26.440
data to the stored procedure, which in turn
managed inserting that data appropriately,

00:00:26.440 --> 00:00:31.880
into related tables in the music database.
In addition to passing data as parameters

00:00:31.880 --> 00:00:35.302
into a procedure, there are a
couple of ways to get data back.


00:00:36.258 --> 00:00:40.623
First,MySQL has three different types
of parameter types for it's procedures.


00:00:41.600 --> 00:00:46.640
The in Parameter is a read only parameter, and
the default type, meaning we don't have to specify

00:00:46.640 --> 00:00:51.983
the keyword, in, in our MySQL procedures,
if this the type of parameter you want.


00:00:52.960 --> 00:00:56.364
This is data you pass to the procedure,
and it doesn't get modified.


00:00:57.280 --> 00:01:02.364
The OUT parameter is a write only parameter.
You must specify the OUT type for this one.


00:01:03.320 --> 00:01:07.360
The in, OUT parameter is a hybrid
parameter, so you can pass data in,

00:01:07.360 --> 00:01:13.320
which the procedure can modify, and return.
These types are specific to MySQL,

00:01:13.320 --> 00:01:17.562
but many vendors have similar types, the
syntax just might be slightly different.


00:01:18.600 --> 00:01:23.520
This is where JDBC is an advantage, because
you, as a developer, don't really need to

00:01:23.520 --> 00:01:27.960
worry about the syntax, just the concepts,
and how to interact with code that has these

00:01:27.960 --> 00:01:31.760
different parameter types.
I'll start first, with an

00:01:31.760 --> 00:01:37.160
example of the out parameter.
To set this up, I'll open up my

00:01:37.160 --> 00:01:39.666
development session on My SQL Workbench.

00:01:44.387 --> 00:01:46.285
I'll expand the Stored Procedures,

00:01:46.320 --> 00:01:49.758
and click on the add Album procedure
there, and select the tool icon.


00:01:51.040 --> 00:01:56.760
This opens the edit window, and I can edit this.
I'll add a new line after the localhost value,

00:01:56.760 --> 00:02:01.800
in the CREATE DEFINER statement.
The use of CREATE DEFINER is important,

00:02:01.800 --> 00:02:05.484
in situations where you want to control
who can execute this procedure.


00:02:06.400 --> 00:02:10.862
In this case, this means the procedure will
get executed with dev user's privileges.


00:02:11.778 --> 00:02:14.720
Right now, you don't have to worry
about too much about this statement,

00:02:14.720 --> 00:02:18.680
or the code in this procedure.
This first bit, is added

00:02:18.680 --> 00:02:23.920
automatically if you create a new procedure.
What I want to do here is, change the procedure

00:02:23.920 --> 00:02:29.840
name, from addAlbum to addAlbumReturn Counts.
By doing this, I'll actually be creating a new

00:02:29.840 --> 00:02:33.240
procedure with this name.
Before I save this though,

00:02:33.240 --> 00:02:37.080
I'll add a fourth parameter.
I'll start with the key word OUT,

00:02:37.080 --> 00:02:41.856
and by convention this is upper case, my parameter
name will be count, and it's type is int.


00:02:43.240 --> 00:02:48.746
I could also change my other 3 parameters, and
include the key word, In, and I'll do this.


00:02:51.880 --> 00:02:56.055
It's usually best practice, to explicitly
specify the in parameter type,

00:02:56.055 --> 00:03:00.187
though not required, as you saw.
I'll hit the Apply button.


00:03:01.240 --> 00:03:03.844
That will popup the DDL
script that'll get executed.


00:03:04.760 --> 00:03:07.780
I'll hit apply again.
Then finish.


00:03:10.080 --> 00:03:13.164
I'll refresh the schema panel, and I
should see my new procedure there.


00:03:14.120 --> 00:03:16.640
So I created an OUT Parameter,
but I didn't actually do

00:03:16.640 --> 00:03:22.000
anything with this parameter, in my code.
I still have the procedure up in the edit window,

00:03:22.000 --> 00:03:27.360
so I'll scroll to the end of this code.
Right after the commit, I'll set the count

00:03:27.360 --> 00:03:31.756
variable, to the value in the eye variable,
which will tell me how many songs got inserted.


00:03:33.160 --> 00:03:36.443
I'll say again, don't get too stressed
about the code in this procedure.


00:03:37.440 --> 00:03:41.600
If you follow along with me, this should
compile fine, and you don't really need to

00:03:41.600 --> 00:03:46.640
understand all the details about how this works.
I've also included this procedure's script in

00:03:46.640 --> 00:03:52.720
the resources folder, if you have any troubles.
You can drop your version, and import the script,

00:03:52.720 --> 00:03:56.024
like I showed you, with the first
procedure in a previous video.


00:03:56.960 --> 00:04:00.734
For now, I'll again Apply that,
twice, and then hit finish.


00:04:02.240 --> 00:04:06.142
I'll open an S Q L edit panel, and
delete all my data for Bob Dylan again.


00:04:07.160 --> 00:04:11.040
So that's delete from music.artists,
where artist_name equals,

00:04:11.040 --> 00:04:12.806
and Bob Dylan in single quotes.


00:04:17.039 --> 00:04:19.400
Now, let's get back to IntelliJ,

00:04:19.400 --> 00:04:23.560
to the PreparedStatement project from the
last video, and to the class I was using

00:04:23.560 --> 00:04:28.400
previously, MusicCallableStatement.
In this code, I'll change the name of

00:04:28.400 --> 00:04:32.075
the stored procedure that gets called,
in the callable statement code here.


00:04:33.520 --> 00:04:36.232
I'll run this now, executing
the new stored procedure.


00:04:38.919 --> 00:04:43.520
This time, I get an error for each
attempt, that the parameter, named count,

00:04:43.520 --> 00:04:48.522
is not registered as an output parameter.
There are a couple of problems here actually.


00:04:49.560 --> 00:04:53.320
First, I need another question
mark, as a parameter placeholder,

00:04:53.320 --> 00:04:57.436
in the call to this stored procedure.
So I'll quickly add that.


00:04:58.840 --> 00:05:05.485
And I'll try running this again.
And now this works, and data gets added.


00:05:06.360 --> 00:05:09.286
So registering an out parameter,
isn't actually required.


00:05:10.120 --> 00:05:13.284
You register the out parameter,
if you want to get the data back.


00:05:14.200 --> 00:05:17.400
Since I do want the result, that
gets passed back in that parameter,

00:05:17.400 --> 00:05:22.384
I'll show you how to do that next.
To get that data, there are two steps.


00:05:23.320 --> 00:05:27.440
Before the execute method, I need to call
register out parameter, specifying the

00:05:27.440 --> 00:05:33.307
index as 4. The second parameter is the data
type, and I'll set that to Types dot integer.


00:05:35.240 --> 00:05:40.240
Types is a class in the java.sql package,
which defines constants used to identify

00:05:40.240 --> 00:05:46.102
generic SQL types, called JDBC types,
which will be translated to java types.


00:05:47.120 --> 00:05:51.321
That's the first thing that needs to be done,
to get data returned on the Callable Statement.


00:05:52.298 --> 00:05:56.004
The next part is to retrieve this data
from the statement, after it's executed.


00:05:56.920 --> 00:06:03.320
I'll print the number of songs, and the album
name. I can get the output parameter's value,

00:06:03.320 --> 00:06:07.870
by calling get Int, and passing the
appropriate index, so the index is four here.


00:06:09.498 --> 00:06:14.200
Before I run this, I want to again delete the
data for Bob Dylan, so I'll jump back to the

00:06:14.200 --> 00:06:18.528
MySQL Workbench session, and re execute
the delete artists statement there.


00:06:20.400 --> 00:06:23.478
And now, back to IntelliJ, I'll run my code.


00:06:27.975 --> 00:06:29.833
Before all the records are printed,

00:06:29.960 --> 00:06:35.520
notice the two statements there.
13 songs were added for the album, Bob Dylan,

00:06:35.520 --> 00:06:40.840
and 14 songs were added for Blonde on Blonde.
So that's a demonstration, of two way

00:06:40.840 --> 00:06:45.960
communication with a stored procedure.
Next, I'll create a third procedure,

00:06:45.960 --> 00:06:50.520
in MySQL Workbench.
This script will be in the resources folder as

00:06:50.520 --> 00:06:55.604
well, if you encounter any problems, just editing
the current procedure, which I'll do here now.


00:06:56.520 --> 00:07:00.960
I'll be creating this manually, by editing
another procedure, so I'll open the add Album

00:07:00.960 --> 00:07:03.725
Return Counts procedure, using the tool icon.

00:07:11.235 --> 00:07:14.537
I'll change the name to add Album, In, Out, Counts,

00:07:14.632 --> 00:07:19.182
and I'll change that fourth parameter
from an out parameter, to an In, out, parameter.


00:07:20.098 --> 00:07:27.640
Before I apply these changes, I'll scroll to
the bottom, and add an if statement, around the

00:07:27.640 --> 00:07:33.040
code that sets the value of the count parameter.
In this case, I'll check if the number of records

00:07:33.040 --> 00:07:38.920
that got inserted, equals the count, passed
as a parameter. If this were a real scenario,

00:07:38.920 --> 00:07:43.800
I might do something additional, like log the
information, or pass data to an audit table,

00:07:43.800 --> 00:07:45.323
or raise some kind of error.



00:07:47.093 --> 00:07:48.279
I'll hit apply again,

00:07:51.149 --> 00:07:52.050
then finish.

00:07:53.280 --> 00:07:57.880
I'll refresh the schema panel.
I'll see my third stored procedure there,

00:07:57.880 --> 00:08:03.320
and now I can use it in my JDBC code.
I'll again go to an S Q L editing panel,

00:08:03.320 --> 00:08:07.480
and delete the data for Bob Dylan.
Getting back to my Java code in

00:08:07.480 --> 00:08:13.280
IntelliJ, I'll make two changes to my code.
First I'll change the name of the procedure I'm

00:08:13.280 --> 00:08:17.570
calling, so fromaddAlbumReturnCounts,
toaddAlbum, InOutCounts.


00:08:18.720 --> 00:08:24.080
Next, I'll pass an initial value to parameter 4.
Normally, this would be the record count

00:08:24.080 --> 00:08:28.424
you expect to be inserted, but I'll just
set it to an arbitrary number, like 10.


00:08:29.360 --> 00:08:34.133
I'll call set int here, and parameter
is 4, and the value of count is 10.


00:08:35.680 --> 00:08:40.720
I'll run this.
So even though I passed

00:08:40.720 --> 00:08:45.240
in 10 as the count, to parameter 4, you can
see that I'm getting the actual count back,

00:08:45.240 --> 00:08:51.640
13 and 14 songs inserted there.
If I rerun it immediately,

00:08:51.640 --> 00:08:58.600
without first deleting the data,
You can see that 0 records were inserted,

00:08:58.600 --> 00:09:03.680
which is what you'd expect in this case.
Now I'll switch over to MySQL Workbench, and

00:09:03.680 --> 00:09:08.807
once again execute my delete statement.
And now, right back to IntelliJ.


00:09:09.960 --> 00:09:14.240
Before I run the code again, I'll first comment
out the line, where I'm setting the fourth

00:09:14.240 --> 00:09:19.913
parameter, to an initial value, 10 in this case.
I'll see if I can run it this way,


00:09:22.640 --> 00:09:27.805
and yes, you can see this does actually run.
But the results are misleading.


00:09:28.538 --> 00:09:33.023
Notice that I do get data back, when I
just deleted it, before running this code.


00:09:34.000 --> 00:09:39.705
This means this code must have added the data.
But it says 0 songs were added for each album.


00:09:40.600 --> 00:09:43.521
There's a couple of things going
on here, I want to talk about.


00:09:44.640 --> 00:09:47.600
First, even if I don't set the
in out parameter to a value,

00:09:47.600 --> 00:09:52.979
it will get initialized to a default value,
depending on the data type, and the DBMS vendor.


00:09:54.037 --> 00:09:57.561
Here, count wasn't initialized to
zero, it was initialized to null.


00:09:58.640 --> 00:10:03.624
And null has unexpected and sometimes confusing
results in S Q L code, if you're new to it.


00:10:04.560 --> 00:10:08.160
In this stored procedure, I first
check if count is not equal to eye,

00:10:08.160 --> 00:10:12.400
and if it's not, I'll set count.
The reason this returns false

00:10:12.400 --> 00:10:16.223
when value is NULL, is because the NULL
variable represents an unknown value.


00:10:17.200 --> 00:10:21.520
In databases, avariable or parameter
that's null isn't equal to, and it's

00:10:21.520 --> 00:10:26.640
also not equal to, another value.
This had an unexpected result here,

00:10:26.640 --> 00:10:31.963
and could produce unexpected results, if a null
parameter value is used in S Q L statements.


00:10:32.858 --> 00:10:38.279
The moral of the story here is, that you should
always initialize your in and inOUT parameters.


00:10:39.378 --> 00:10:44.004
This way, you can avoid any unexpected behavior
that could arise, as we're seeing here.


00:10:44.920 --> 00:10:47.860
I'll uncomment that line there,
so this code is operational.


00:10:48.816 --> 00:10:52.503
Ok, so those are the two ways to get
data back from a stored procedure.


00:10:53.480 --> 00:10:57.280
There's another way to get data back
from stored code in the database server,

00:10:57.280 --> 00:11:01.884
and that's by using Callable statement, but
executing a function, rather than a procedure.


00:11:02.840 --> 00:11:07.742
A function's purpose is to return a value, usually
the result of some calculation or formula.


00:11:08.800 --> 00:11:13.440
In contrast, a stored procedure is often
used for performing a sequence of operations,

00:11:13.440 --> 00:11:17.163
data manipulation, or enforcing
business rules within the database.


00:11:18.160 --> 00:11:19.840
So I'll continue in the next video,

00:11:19.840 --> 00:11:24.560
and look at MySQL functions, and how to
execute and use them with JDBC code.
