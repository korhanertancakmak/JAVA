WEBVTT
Kind: captions
Language: en

00:00:05.680 --> 00:00:10.964
So far, up until now, to run SQL on the server,
I've first constructed a static string.


00:00:11.880 --> 00:00:16.960
This was done by either hard coding all values
to be used in the query, by string concatenation,

00:00:16.960 --> 00:00:20.480
or using formatted strings.
I've then called any one of

00:00:20.480 --> 00:00:24.044
several execute methods, which in
general follow the same process.


00:00:24.960 --> 00:00:28.560
When the request is received
by the Database Server


00:00:28.560 --> 00:00:33.440
the Query is Parsed into operable code,
which means The S Q L syntax is checked,

00:00:33.440 --> 00:00:39.000
and Tables and column names are verified. An
Execution Plan is Created, which means the

00:00:39.000 --> 00:00:43.723
database server analyzes the query, and works
out an optimal way to execute the statement.


00:00:44.680 --> 00:00:49.000
The result is a compiled statement.
Once the statement is compiled,

00:00:49.000 --> 00:00:54.240
it's stored in a cache on the database server.
This means it can be reused, without having

00:00:54.240 --> 00:01:00.280
to be recompiled each time it is executed.
Importantly, this compiled statement, can also be

00:01:00.280 --> 00:01:07.160
stored as a special kind of JDBC statement.
A PreparedStatement in JDBC,

00:01:07.160 --> 00:01:12.080
is a precompiled SQL statement.
You might remember, when we were reviewing

00:01:12.080 --> 00:01:17.323
regular expressions, we could get a compiled
regular expression, by using the Pattern.compile.


00:01:18.280 --> 00:01:22.023
In some ways, this is similar to
precompiling an S Q L statement.


00:01:22.960 --> 00:01:27.120
In both cases, a String is passed,
which needs to get interpreted,

00:01:27.120 --> 00:01:31.840
as some operation that will occur.
The string first needs to get parsed,

00:01:31.840 --> 00:01:35.924
its syntax tested, and some
optimizations may optionally be applied.


00:01:36.840 --> 00:01:41.080
There is some overhead with this process, so
if you're using the statement multiple times,

00:01:41.080 --> 00:01:46.480
it makes sense to precompile it.
A PreparedStatement is used to execute

00:01:46.480 --> 00:01:50.428
the same statement multiple times,
with parameter value placeholders.


00:01:51.240 --> 00:01:55.040
This can improve performance, as
I just stated, since the database

00:01:55.040 --> 00:01:58.881
server doesn't need to parse and compile
the statement, each time it is executed.


00:01:59.880 --> 00:02:04.160
A parameter in an SQL string passed to a
PreparedStatement, is defined with a question

00:02:04.160 --> 00:02:09.680
mark as a placeholder, shown in this example.
Notice here, that I'm not including single

00:02:09.680 --> 00:02:14.440
quotes around the question mark.
This is because, when you use a prepared

00:02:14.440 --> 00:02:19.343
statement, the work of enclosing literals,
is determined by the type and done for us.


00:02:20.280 --> 00:02:23.960
When you use the prepared statement,
you'll pass the values at that time,

00:02:23.960 --> 00:02:28.920
specifying their data types as well.
This means the values passed as data,

00:02:28.920 --> 00:02:34.760
will never be interpreted as S Q L code.
Because of this, and very Importantly,

00:02:34.760 --> 00:02:38.020
PreparedStatements help
prevent SQL injection attacks.


00:02:40.080 --> 00:02:44.100
You can have multiple parameters in the SQL
string, and they can be different types.


00:02:45.120 --> 00:02:48.399
For example, album id in the
songs table is a number.


00:02:49.398 --> 00:02:53.520
Specifying placeholders is the same,
regardless of the type of parameter,

00:02:53.520 --> 00:02:58.320
as I show here, in this example.
Let's get back to some code,

00:02:58.320 --> 00:03:00.588
and set up a couple of prepared statements.


00:03:02.940 --> 00:03:07.250
To demonstrate the prepared statement, I've created a new Project called PreparedStatement.

00:03:08.226 --> 00:03:10.960
I've added the MySQL JDBC driver jar file

00:03:10.960 --> 00:03:13.928
as a library jar, which you
should know how to do by now.


00:03:14.760 --> 00:03:18.204
I've got the usual Main class in
this project in the dev lpa package.


00:03:19.120 --> 00:03:24.200
In this code, I'll again use a datasource.
In a server environment, you wouldn't

00:03:24.200 --> 00:03:27.840
be instantiating a new instance of a
known driver class like we'll do here,

00:03:27.840 --> 00:03:33.000
but all other operations would be the same.
I'll create a new source, with my specific

00:03:33.000 --> 00:03:38.560
driver here, which gives me a basic data source.
You may or may not have to manually include an

00:03:38.560 --> 00:03:44.640
import statement for this, since IntelliJ may
not. You should be able to hover over that class,

00:03:44.640 --> 00:03:50.720
and select import class in most cases, if the
auto import doesn't work. I'll use the set methods

00:03:50.720 --> 00:03:59.680
on the data source, to set the server name, so
localhost, the port, 3306, and the database name,

00:03:59.680 --> 00:04:05.160
so I'll be using music again for this video.
In a previous video I added a property on the

00:04:05.160 --> 00:04:09.243
connection string, called set continue
batch on error, which I set to false.


00:04:10.200 --> 00:04:14.080
Without setting this to false, my
batched statements will all get executed,

00:04:14.080 --> 00:04:19.240
instead of stopping at the first error.
I can use one of the set methods, on my datasource

00:04:19.240 --> 00:04:25.040
to do this, so I'll call setContinueBatchOnError.
I need to wrap that with a try catch,

00:04:25.040 --> 00:04:27.279
so I'll use IntelliJ's help to do that.


00:04:29.631 --> 00:04:32.607
I'll set up my username and password as
environment variables,

00:04:32.607 --> 00:04:34.225
whichI've done multiple times.


00:04:35.120 --> 00:04:38.319
So I'll select Run from the
menu, then edit configurations.


00:04:39.880 --> 00:04:43.577
In the dialog, I'll set up the two
variables as I did previously.


00:04:53.640 --> 00:04:56.865
Ok, once we've done that, I'll
get a connection next in my code.


00:04:58.800 --> 00:05:02.879
I'll do this in a try with resources, and call
get Connection on data source.

00:05:03.795 --> 00:05:07.692
I'll pass the environment variables, for the username, and
password.


00:05:10.855 --> 00:05:12.584
I'll add the usual catch clause.

00:05:15.080 --> 00:05:18.360
Next I'll set up a simple select
statement, as a string, which will

00:05:18.360 --> 00:05:23.360
get data from the music.albumview.
You've seen this before, but now,

00:05:23.360 --> 00:05:28.920
instead of using a formatted static string, or a
concatenated string, for the artist name value,

00:05:28.920 --> 00:05:33.920
I'll insert a question mark there. This
is how you parameterize an SQL statement,

00:05:33.920 --> 00:05:39.796
when you plan to use it in a prepared statement.
I'll set up my prepared statement, which I'll call ps.

00:05:40.795 --> 00:05:45.259
 I'll call connection.prepareStatement,
passing this method the SQL string variable.

00:05:46.216 --> 00:05:50.881
Next,I can set the value of that parameter, by
calling setString on the prepared statement.

00:05:51.880 --> 00:05:59.000
This method takes an index, and again, S Q L
starts at index 1. I'll pass Elf as the value,

00:05:59.000 --> 00:06:04.680
the artist, to this statement. I can invoke
executeQuery on a prepared statement as well,

00:06:04.680 --> 00:06:09.000
which will return a result set.
So note, I'm not calling

00:06:09.000 --> 00:06:13.160
the enquote literal method.
When replacing a placeholder in a prepared

00:06:13.160 --> 00:06:18.678
statement, you specify the type, by calling the
relevant set method, set string in this case.


00:06:19.760 --> 00:06:23.763
The server will appropriately enquote
literals as needed, based on that type.


00:06:24.637 --> 00:06:27.361
Before I run this, I'll
add a printRecords method.


00:06:28.360 --> 00:06:32.366
I had this method, in the QueryMusic
project's MusicDML class.


00:06:33.240 --> 00:06:38.385
I'll just paste this into my class, and since I've
discussed it previously, I won't re hash it here.


00:06:39.280 --> 00:06:44.080
Getting back to the main method,
I'll add a call to the printRecords,

00:06:44.080 --> 00:06:48.640
after I execute the query.
Ok, as you can see,

00:06:48.640 --> 00:06:52.280
it's not too different from a Statement,
except when you get a preparedStatement,

00:06:52.280 --> 00:06:58.560
you have to pass a sql statement to that method.
In most cases, this SQL statement is sent to the

00:06:58.560 --> 00:07:02.641
DBMS, when you call prepareStatement,
and it gets compiled at that point.


00:07:03.640 --> 00:07:07.707
This means the prepared statement object
contains a precompiled statement instance.


00:07:08.560 --> 00:07:11.884
That then gets passed to the server,
when statements are executed.


00:07:12.800 --> 00:07:15.440
The string that gets passed to
the prepareStatement method,

00:07:15.440 --> 00:07:19.960
can optionally contain parameters.
Parameters are specified using question

00:07:19.960 --> 00:07:25.000
marks in the query statement, as I showed you on
the slides, so these are placeholders for data.


00:07:25.840 --> 00:07:28.500
I can set the parameter values
by calling a set method.


00:07:29.416 --> 00:07:32.662
These placeholders are another important
feature of the prepared statement.


00:07:33.640 --> 00:07:39.078
They ensure that user input is always treated as
data values, and never as executable SQL code.


00:07:40.160 --> 00:07:43.943
This makes it difficult for attackers
to inject malicious SQL statements.


00:07:44.880 --> 00:07:48.423
In this case, I use set
String, to set the data value.


00:07:49.360 --> 00:07:53.960
If the data type is something else, there's
a whole series of set methods to choose from,

00:07:53.960 --> 00:07:59.320
like setArray, setBlob, and the usual
ones, setLong, setDouble and so forth.


00:08:00.360 --> 00:08:01.459
I'll run this code.


00:08:04.373 --> 00:08:06.935
And here I get the data for the artist Elf's two albums.

00:08:07.931 --> 00:08:10.506
Another important aspect of the prepared
statement

00:08:10.506 --> 00:08:14.800
 is it's ability to be reused.
I'll next use preparedStatements,

00:08:14.800 --> 00:08:21.084
to again insert data into the music database.
This time I'll insert the data from a csv file.


00:08:22.000 --> 00:08:27.585
You can find this file, named NewAlbums.csv,
in the resources section of this video.


00:08:28.480 --> 00:08:30.907
I've included the file at the
root of my project folder.


00:08:31.760 --> 00:08:38.760
I'll open this, so you can see what it contains.
In this case, I've got two of Bob Dylan's

00:08:38.760 --> 00:08:43.590
albums set up as a series of records.
This looks a lot like the album view.


00:08:44.360 --> 00:08:49.368
Each record has the artist name, the album
name, the track number, and the song title.


00:08:50.200 --> 00:08:53.645
I'll start with the parameterized
strings, as static strings.


00:08:57.120 --> 00:09:02.920
The first will be the Artist insert statement.
This is a simple insert statement, that inserts

00:09:02.920 --> 00:09:10.400
one parameterized value, the artist name. Next
is the Album insert statement. the album insert

00:09:10.400 --> 00:09:14.640
statement has two columns which need to be
added, the artist id and the album name,

00:09:14.640 --> 00:09:21.480
so I'll set up two placeholders. Lastly,
there's the song insert statement. Here,

00:09:21.480 --> 00:09:29.120
we've got 3 columns, and 3 placeholders,
for album id, track number, and song title.


00:09:34.096 --> 00:09:38.760
Next, I'll create a method called addArtist.
This will take a prepared statement,

00:09:38.760 --> 00:09:43.508
a connection, and an artist name.
It throws an S Q L exception.


00:09:44.840 --> 00:09:50.780
I'll initialize the artist id to minus one. I'll
set the first parameter, to the artist name.

00:09:51.696 --> 00:09:57.480
I'll then call executeUpdate, to get the insert count.
If the count is greater than zero, I'll get the

00:09:57.480 --> 00:10:03.640
generated key, which is the artist id. I get
any generated keys by calling getGeneratedKeys

00:10:03.640 --> 00:10:10.680
on the prepared statement. That returns a result
set containing the keys. I'll get the first key,

00:10:10.680 --> 00:10:15.542
since I'll only have one record. And I'll set
id to the first field in the result set.

00:10:16.874 --> 00:10:17.894
I'll print that out.

00:10:21.161 --> 00:10:25.471
And I'll return the artist id
from this method, because I'll need it when I insert the other records.

00:10:27.218 --> 00:10:30.268
I'll copy that code, and make a copy directly below.

00:10:32.141 --> 00:10:33.561
I'll change the name to addAlbum,

00:10:35.163 --> 00:10:40.920
and insert an artist id as the third argument.
I need to change artist name to album name,

00:10:40.920 --> 00:10:45.120
for the fourth argument.
In the ps.setString statement,

00:10:45.120 --> 00:10:50.518
I have to both change the parameter index, from
1 to 2, and change artistName to albumName


00:10:51.454 --> 00:10:55.585
Next, I'll change album Id to
artistId, in four instances.


00:10:56.480 --> 00:10:59.040
So first, when I'm declaring the first variable.


00:11:01.560 --> 00:11:05.787
Then in the if generatedKeys.next block,
where I assign the generated key.


00:11:06.640 --> 00:11:09.055
And I want to print album id
in the statement after that.


00:11:10.000 --> 00:11:13.863
Lastly, I'll return album id,
not artist id from this method.


00:11:15.416 --> 00:11:19.496
Finally, I need to include the artist
id as the first parameter that gets set,

00:11:19.600 --> 00:11:23.880
on the prepared statement.
The first parameter in the s q l,

00:11:23.880 --> 00:11:29.872
is for artist id. This time, I'll use set
int to do this, passing it artist id.


00:11:30.600 --> 00:11:33.791
For the next method, addSong,
I'll just type this one in.


00:11:35.560 --> 00:11:38.982
This method starts the same way,
so private, static and int.


00:11:39.960 --> 00:11:44.120
I'll call it add song, and the parameters
are PreparedStatement, connection,

00:11:44.120 --> 00:11:50.398
album id, track number, and song title.
This also throws an S Q L Exception.


00:11:51.480 --> 00:11:57.200
I'll set the initial value of the song Id to
minus one. The first parameter is the album id,

00:11:57.200 --> 00:12:03.920
an int. The second parameter is another
int, the track number. And then song title,

00:12:03.920 --> 00:12:09.200
a string, as the third one. I'll call
executeUpdate on the prepared statement,

00:12:09.200 --> 00:12:14.720
and that returns the number of rows inserted.
if something was inserted, then, I'll retrieve

00:12:14.720 --> 00:12:22.720
the generated key, the song id. First I'll call
next on that result set. Then, the first column

00:12:22.720 --> 00:12:26.158
will contain the song id. I'll print that out.


00:12:30.133 --> 00:12:32.360
Now I've got add methods for all three tables,

00:12:32.360 --> 00:12:35.760
related to an artist.
I need to create a method that

00:12:35.760 --> 00:12:40.361
loops through the records in the csv file, and
then calls each of these methods appropriately.


00:12:41.360 --> 00:12:46.040
Because this video is getting a bit long, I'll
end this video here, and finish coding this last

00:12:46.040 --> 00:12:51.080
method and running the code, in the next video.
So I'll see you in that next video.
