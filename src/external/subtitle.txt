WEBVTT
Kind: captions
Language: en

00:00:05.538 --> 00:00:10.769
In the last couple of videos, we looked at
stored procedures, how to call them, and also,

00:00:10.769 --> 00:00:16.280
how in some cases we can get data back.
As already discussed, Stored procedures are

00:00:16.280 --> 00:00:21.119
designed to execute a sequence of SQL statements,
and can perform multiple operations within

00:00:21.119 --> 00:00:25.420
a single call.
They can modify the state of the database,

00:00:25.420 --> 00:00:30.811
meaning they can create, update, or delete
data, as the addAlbum series of procedures did.

00:00:31.757 --> 00:00:34.750
Procedures can also control transaction management,

00:00:34.750 --> 00:00:41.590
ensuring data consistency and integrity.
In relational database management systems,

00:00:41.590 --> 00:00:46.920
like MySQL, precompiled collections of SQL
statements, can be either a stored procedure

00:00:46.920 --> 00:00:51.160
or a stored function.
Both are stored in the database, and both

00:00:51.160 --> 00:00:55.910
can be executed as a single unit.
While each may encapsulate common database

00:00:55.910 --> 00:01:00.690
operations, they are different.
Specifically, stored functions are designed

00:01:00.690 --> 00:01:05.688
to perform a specific calculation, or data
manipulation, and return a single value.

00:01:07.558 --> 00:01:10.880
The key characteristics of a stored function
are

00:01:10.880 --> 00:01:17.080
One, as I just stated, It Returns a value.Stored
functions are expected to return a single

00:01:17.080 --> 00:01:25.390
value, such as an integer, string, date, or
a result set.; Two, a stored function IsImmutable.

00:01:25.390 --> 00:01:28.920
Stored functions are generally designed to
be deterministic, and should not have side

00:01:28.920 --> 00:01:33.750
effects,This means that calling a function
with the same inputs, should always produce

00:01:33.750 --> 00:01:40.360
the same output, and functions should not
modify data in the database. Lastly, a stored

00:01:40.360 --> 00:01:44.840
function Can be used inSQL expressions:
This means You can use it directly in SELECT

00:01:44.840 --> 00:01:49.633
statements, WHERE clauses, or JOIN conditions,
to compute values used in queries.

00:01:51.734 --> 00:01:56.183
The table on this slide, lists some of the
use cases for each of these stored objects.

00:01:57.084 --> 00:02:00.189
You can think of a function as a targeted
and individual unit of work.

00:02:01.205 --> 00:02:05.000
It can be used for validating data, before
insertion or updating.

00:02:05.839 --> 00:02:10.175
A stored function can be used for converting
data, from one format, to another.

00:02:11.145 --> 00:02:15.287
It can be used, to reuse complex expressions,
that are used frequently.

00:02:16.210 --> 00:02:20.476
Finally, a stored function is often used to
perform some calculation or formula.

00:02:21.468 --> 00:02:27.197
On the other hand, a stored procedure is like a mini program in the database, and has much broader objectives.

00:02:28.167 --> 00:02:30.750
Use a stored procedure for data modifications,

00:02:30.750 --> 00:02:37.700
like inserting, updating or deleting records.
Stored procedures are often used to Extract,

00:02:37.700 --> 00:02:42.383
Transform and Load data (making use of functions)
to load data from one table to another.

00:02:43.352 --> 00:02:48.263
Or maybe you've got some business logic, these
rules can be encapsulated in a stored procedure.

00:02:49.118 --> 00:02:53.479
And we've already seen that a stored procedure
can be used for batch and transactional processing.

00:02:55.810 --> 00:02:59.580
You might be less likely to call a stored
function from your CallableStatement, than

00:02:59.580 --> 00:03:02.299
you would a Stored Procedure, but I still
want to cover it.

00:03:03.038 --> 00:03:07.830
There are a couple of differences,
The first is that the S Q L string will always

00:03:07.830 --> 00:03:11.664
start with a placeholder, so a question mark,
for the returned result.

00:03:12.680 --> 00:03:19.050
The second is that MySQL stored functions
only support IN Parameters. This isn't true

00:03:19.050 --> 00:03:22.930
for other vendors.
This just means you don't specify parameter

00:03:22.930 --> 00:03:27.338
types, in the parameter declarations of the
stored function, in MySQL.

00:03:29.785 --> 00:03:35.628
First, let's get started, by loading and examining,
a simple function in MySQL Workbench.

00:03:36.575 --> 00:03:42.359
First, download the file called calcAlbum
Length.sql, from the resources folder of this video.

00:03:43.490 --> 00:03:46.040
Open MySQL Workbench, and use the development

00:03:46.040 --> 00:03:50.529
session we've been using all along.
Make sure you have the schemas panel open.

00:03:51.476 --> 00:03:56.599
Select the second icon from the menu of icons,
which is, open a sql script from a file.

00:03:58.746 --> 00:04:01.529
Browse to the file you downloaded, and select
that.

00:04:07.162 --> 00:04:10.701
I'll select the first lightning icon, and
that will execute this script.

00:04:11.624 --> 00:04:14.866
If I refresh the schema panel, I can open
the Functions node.

00:04:16.274 --> 00:04:19.503
And there I can see the new stored function
there, calcAlbumLength.

00:04:20.888 --> 00:04:26.600
I'll select the tool icon.
What you'll notice is, that this looks a lot

00:04:26.600 --> 00:04:31.590
like a stored procedure.
It has the keyword FUNCTION instead of PROCEDURE,

00:04:31.590 --> 00:04:33.953
but it has parameters defined in a similar
fashion.

00:04:34.876 --> 00:04:39.590
One thing I want to show you is, if I now
decide to declare the input type explicitly,

00:04:39.590 --> 00:04:42.319
by adding the keyword, In, before album
name.

00:04:43.543 --> 00:04:49.000
Notice, that this is an error in this case.
This is one difference, that you don't have

00:04:49.000 --> 00:04:53.199
the option to specify the parameter type in
your stored function, because all parameters

00:04:53.199 --> 00:04:58.570
are by default, type in Parameters.
I'll revert that change, removing IN from

00:04:58.570 --> 00:05:02.440
the parameter declaration.
The next thing you'll notice is that this

00:05:02.440 --> 00:05:07.110
function returns a double.
And then notice the next line, that says READS

00:05:07.110 --> 00:05:10.438
SQL DATA.
I'm going to remove this for a minute.

00:05:12.031 --> 00:05:15.767
I'll apply this change.
And hit apply a second time.

00:05:16.690 --> 00:05:21.100
Now, I've got a problem.
There was an error while applying the SQL

00:05:21.100 --> 00:05:25.760
script to the database.
I'll scroll down a bit, until I see Error

00:05:25.760 --> 00:05:30.020
1 4 1 8.
Here, the statement says, this function has

00:05:30.020 --> 00:05:35.699
none of, DETERMINISTIC, NO SQL, or READS SQL
DATA, in its declaration.

00:05:36.692 --> 00:05:41.800
You might remember, in my introductory slides,
I mentioned that functions should be immutable,

00:05:41.800 --> 00:05:46.220
or deterministic.
Deterministic means that running the code,

00:05:46.220 --> 00:05:49.245
with the same input, should result in the
same output each time.

00:05:50.284 --> 00:05:53.670
And they should never have side effects, like
altering the database state.

00:05:54.640 --> 00:05:59.089
I should specify at least one of these statements
in my function, or if none of these is the case,

00:05:59.227 --> 00:06:02.505
I can pursue another option, which I
won't get into in this course.

00:06:03.590 --> 00:06:09.770
I'll cancel out of this, and now in my code,
I'll type DETERMINISTIC, where I originally

00:06:09.770 --> 00:06:13.485
had READS SQL DATA.
And I'll try to apply that.

00:06:16.671 --> 00:06:20.705
This time it works, meaning it got saved and
compiled, without any errors.

00:06:21.652 --> 00:06:26.020
Although this may work, it doesn't really
make sense in this case, unless the data in

00:06:26.020 --> 00:06:31.627
the tables, will never change.
If the data can change, than it won't be deterministic.

00:06:32.643 --> 00:06:35.000
So I'll revert this code back to the way it
was.

00:06:41.267 --> 00:06:45.810
This is a really simple function
It first counts the number of records in the

00:06:45.810 --> 00:06:50.660
album view for a single album.
Then the code multiplies this, by the static

00:06:50.660 --> 00:06:55.139
value, 2.5.
If song length were part of our songs table,

00:06:55.139 --> 00:06:59.930
then we'd sum up those values.
So here, I'm just mocking up an average length

00:06:59.930 --> 00:07:04.759
of 2.5 minutes per song.
That is selected into the length variable,

00:07:04.759 --> 00:07:08.970
which gets returned from this function.
What's kind of nice about functions is that

00:07:08.970 --> 00:07:11.947
we can use them in select statements, and
where clauses.

00:07:12.825 --> 00:07:15.814
I'll show you this in the workbench, so I'll
open a SQL tab.

00:07:17.430 --> 00:07:22.270
I'll select the distinct album name just in
case this data has duplicates, and now, instead

00:07:22.270 --> 00:07:27.238
of adding another column name, I can call
my function, passing it the album name column name.

00:07:28.184 --> 00:07:30.210
This means this function will get called,

00:07:30.210 --> 00:07:34.611
for every record, with that record's album
name, to calculate the album length.

00:07:35.535 --> 00:07:40.050
I'll select from the albums table, and order
by album name.

00:07:41.943 --> 00:07:43.140
I'll execute this.

00:07:45.657 --> 00:07:48.704
And you'll see a grid displayed, first my
album names,

00:07:48.704 --> 00:07:53.410
listed alphabetically, and then
the result of my function, a double value,

00:07:53.410 --> 00:07:56.536
representing the length, in minutes, of each
album.

00:07:57.529 --> 00:08:02.324
This gives you an idea of relative length,
if all the songs were a uniform recording size.

00:08:03.224 --> 00:08:05.460
Now, let's see how we'd use this in Java code.

00:08:06.591 --> 00:08:09.399
I'll go back to my prepared statement project
in Intelli J.

00:08:10.323 --> 00:08:14.463
I'll be adding code to call this function,
in the MusicCallableStatement class.

00:08:15.433 --> 00:08:18.492
First, I'll comment out the code that calls
the stored procedure.

00:08:19.392 --> 00:08:23.420
I'll use a block comment here, blocking out
everything from the CallableStatement declaration,

00:08:23.420 --> 00:08:25.552
down to the end of the forEach looping.

00:08:29.685 --> 00:08:32.293
I'm going to call my function after the data is printed out,

00:08:32.293 --> 00:08:36.899
 so after Main.printRecords.
Whether you're calling a stored procedure,

00:08:36.899 --> 00:08:42.469
or a stored function, you still call prepareCall,
on the connection. This time I'll assign it

00:08:42.469 --> 00:08:48.029
to a callable statement variable, named c
s f. I'll pass the string that calls the calc

00:08:48.029 --> 00:08:53.970
album length function. In this case, I start
with a question mark and equals sign, followed

00:08:53.970 --> 00:09:00.144
by the keyword call, then the stored function,
music.calcAlbumLength, and that takes one parameter.

00:09:01.644 --> 00:09:04.205
The first question mark is for the result
of the function.

00:09:05.152 --> 00:09:07.124
I only need to register the result once,

00:09:07.124 --> 00:09:12.011
and this is done just like an output parameter.
The returned result is index 1.

00:09:12.911 --> 00:09:17.642
I'll use the java.sql.Types class, to specify the type
as a double.

00:09:21.013 --> 00:09:26.290
Next, I'll loop through my data in the Map,
so through the key, the artist, and the nested

00:09:26.290 --> 00:09:32.028
map, which has all the new album data. I'll
loop through album map, but just the album name keys.

00:09:34.221 --> 00:09:39.491
 I'll include a try clause. I'll
set the function's parameter, index 2, to

00:09:39.491 --> 00:09:44.510
the album Name. What this means is, I'll be
calling the calc album length for each of

00:09:44.510 --> 00:09:50.000
the bob dylan albums in my map. Next, I'll
call execute on the c s f statement.

00:09:50.991 --> 00:09:55.238
I can get the result from the statement, by simply
calling one of the get methods on index 1.

00:09:56.300 --> 00:10:01.430
I'll print this data out, so length of %s,
that'll be the album name, is percent dot

00:10:01.430 --> 00:10:06.761
1f, that'll be the record length. And next,
the usual catch clause.

00:10:10.525 --> 00:10:13.497
Ok so this code is similar to calling a stored
procedure.

00:10:14.420 --> 00:10:15.474
I'll run this now.

00:10:18.706 --> 00:10:22.530
But for this, I'm getting an error, parameter number 1 is not an out parameter.

00:10:23.485 --> 00:10:25.520
This error's a bit confusing, if you don't

00:10:25.520 --> 00:10:29.329
understand the problem.
I'm going to go up to the prepareCall method,

00:10:29.329 --> 00:10:34.620
and make a minor change.
I'll start and end the text that's in quotes,

00:10:34.620 --> 00:10:38.824
with an opening and closing curly brace.
I'll run the code again.

00:10:42.334 --> 00:10:47.120
And scroll to the bottom of the output.
Here, you can see the code ended without any

00:10:47.120 --> 00:10:51.113
errors, and I get the album lengths back,
from executing my function this way.

00:10:52.129 --> 00:10:57.588
The length of Bob Dylan is 32.5, and the length
of blonde on blonde is 35.0.

00:11:00.335 --> 00:11:03.778
What are the curly braces here, and why did
this work?

00:11:04.747 --> 00:11:09.970
Without the curly braces, the JDBC driver
interprets the string literally, so it wants

00:11:09.970 --> 00:11:16.580
to execute a call command, on the database.
But in most databases, you don't execute stored

00:11:16.580 --> 00:11:20.117
functions, using the call keyword, like you
would for a stored procedure.

00:11:21.064 --> 00:11:25.692
Because it thinks you're calling a stored
procedure, the starting question mark is simply ignored.

00:11:26.639 --> 00:11:28.990
That's why we got the error in the first try,

00:11:28.990 --> 00:11:34.411
the parameter number 1 is not an out parameter,
because the driver didn't factor in the first question mark.

00:11:35.334 --> 00:11:38.930
Using the curly braces informs the JDBC driver,

00:11:38.930 --> 00:11:41.826
that you want it to perform extra processing,
or translation.

00:11:42.749 --> 00:11:47.482
These curly braces are called an escape sequence,
and they're supported in special cases.

00:11:49.605 --> 00:11:55.440
JDBC Escape sequences provide a way to execute
database-specific operations, in a more consistent

00:11:55.440 --> 00:11:58.451
and portable manner, across different database
systems.

00:11:59.351 --> 00:12:03.368
They're enclosed in curly braces {},and are
used within SQL statements.

00:12:04.292 --> 00:12:06.766
There are certain things that aren't database
agnostic.

00:12:07.712 --> 00:12:11.169
This includes Date, time, and timestamp literals.

00:12:12.116 --> 00:12:15.417
You saw this, when I gave you a specific format for the date,

00:12:15.417 --> 00:12:17.572
in MySQL, in a challenge.

00:12:18.357 --> 00:12:21.881
The default date format is different, depending on the database.

00:12:22.766 --> 00:12:26.620
 Scalar functions such as
numeric, string, and data type conversion

00:12:26.620 --> 00:12:32.580
functions may differ. For example, the function
to transform a string to upper case, may have

00:12:32.580 --> 00:12:38.230
a different name in various databases. Escape
characters for wildcards used in LIKE clauses

00:12:38.230 --> 00:12:43.410
may be different between databases. And the
execution ofStored procedures and functions

00:12:43.410 --> 00:12:49.790
may be performed with either a call, or execute
method, or some other key word. Similarly,

00:12:49.790 --> 00:12:53.440
the execution of a function may be performed
differently across databases.

00:12:54.271 --> 00:12:59.350
For these features, and a few others, you
can use an escape sequence, usually with special

00:12:59.350 --> 00:13:04.570
syntax specified.
In the case of stored functions, the key is,

00:13:04.570 --> 00:13:07.080
the question mark equals CALL, part of the
string.

00:13:07.981 --> 00:13:13.253
This informs the JDBC driver, that you want
it to prepare the code, to execute a function.

00:13:14.268 --> 00:13:18.810
The other items listed on this slide, have
special indicators as well, and you can find

00:13:18.810 --> 00:13:22.573
these by googling JDBC escape sequences, if
you're interested.

00:13:23.635 --> 00:13:26.829
You might be wondering why I didn't need the
escape sequence for the stored procedures

00:13:26.829 --> 00:13:31.959
we looked at, in the last video.
In general the key word call, is supported

00:13:31.959 --> 00:13:38.480
by most databases for stored procedures.
This means I could go over to the MySQL workbench,

00:13:38.480 --> 00:13:44.066
and execute the call command, with the procedure
name and specified parameters, in a SQL Query editor.

00:13:45.000 --> 00:13:47.750
I could do the same in most RDBMS's, so the

00:13:47.750 --> 00:13:51.508
use of the escape sequences in a stored procedure
call, is often optional.

00:13:52.478 --> 00:13:57.790
The execute of a function isn't done with
the command call, in MySQL, so as you saw,

00:13:57.790 --> 00:14:01.206
we needed to escape this string, which allowed
it to run successfully.

00:14:03.283 --> 00:14:08.589
Stored procedures are designed for executing
multiple operations, modifying data, and enforcing

00:14:08.589 --> 00:14:12.839
business logic.
In contrast, stored functions are primarily

00:14:12.839 --> 00:14:19.709
used for calculations and data transformations.
Both enhance code reusability, improve performance,

00:14:19.709 --> 00:14:22.980
and promote encapsulation of complex database
operations.

00:14:23.950 --> 00:14:27.583
And even better, they simplify the JDBC code
you have to write.

00:14:28.622 --> 00:14:32.130
Now that you're a little familiar with stored
procedures and stored functions, I've got

00:14:32.130 --> 00:14:33.890
a challenge for you coming up next.

00:14:34.883 --> 00:14:36.930
So I'll see you in the next video for that challenge.
