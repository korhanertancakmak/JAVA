WEBVTT
Kind: captions
Language: en

00:00:05.360 --> 00:00:09.240
In the last video, we connected to
the music database, first using a

00:00:09.240 --> 00:00:15.120
Driver Manager, than using a DataSource.
In this video, I'll start with a new project,

00:00:15.120 --> 00:00:17.920
called QueryMusic.
It has the usual

00:00:17.920 --> 00:00:22.760
Main class in dev lpa, and so on.
I'll show you how to add the MySQL

00:00:22.760 --> 00:00:26.778
driver jar to the project again here, as
a library in my module settings.

00:00:27.814 --> 00:00:32.073
You'll need to do this, before proceeding, if
you're creating a new project as well.


00:00:33.680 --> 00:00:38.600
Rather than getting user name &amp; password,
with swing UI components, which gets old fast,

00:00:38.600 --> 00:00:43.343
this time, I'll use a combination of a
properties file, and an environment variable.


00:00:44.273 --> 00:00:49.080
Again, it's important to research best practices
for your own environment, and I'm not recommending

00:00:49.080 --> 00:00:54.720
this approach, for a production application.
To start, I'll open the project panel,

00:00:54.720 --> 00:00:59.264
and create a new file, at the project
root, called music.properties.


00:01:00.640 --> 00:01:03.596
This file will just contain
plain text key value pairs.


00:01:04.400 --> 00:01:08.160
In the editor window, I'll enter the
data I need to connect to a datasource,

00:01:08.160 --> 00:01:12.960
without using a connection string.
This includes the server name or host,

00:01:12.960 --> 00:01:17.556
and I'll make that localhost, the port,
the database name, so music there.


00:01:18.360 --> 00:01:20.334
I'll enter dev user as the user
name.

00:01:21.328 --> 00:01:26.880
For now, I'm just going to put asterisks here in the password value.
You're welcome to enter your password

00:01:26.880 --> 00:01:30.480
there for your own testing, but I'll
instead use an environment variable,

00:01:30.480 --> 00:01:34.680
to add another level of security.
I could set this up on my operating

00:01:34.680 --> 00:01:38.095
system, but I can also just make
it part of my build configuration.


00:01:39.026 --> 00:01:42.488
So I'll go to the Run menu Item,
then select Edit Configurations.


00:01:44.200 --> 00:01:50.000
As you can see, the configurations pane is
empty. So, I'll exit this and run the program,

00:01:51.320 --> 00:01:54.639
which creates a configuration, and
then come back to this screen again.


00:01:57.240 --> 00:02:01.040
You can see there's a text field where you can
enter a list of additional environment variables,

00:02:01.040 --> 00:02:05.950
so I'll enter my SQL underscore PASS there,
and equals, and set that to my password.

00:02:07.240 --> 00:02:11.840
Obviously I'll blur out my password.
Getting back to the code, in the main

00:02:11.840 --> 00:02:16.646
method,I'll set up a properties variable.
I'll do this at the start of this main method.


00:02:17.640 --> 00:02:23.040
Because I'm reading data from a file, I
need a try catch. The properties object,

00:02:23.040 --> 00:02:28.560
has a load method, that takes an input stream, so
I'll set that up to use the music properties file,

00:02:28.560 --> 00:02:36.080
at the project root. This file will be set to READ
only. I'll catch the IO Exception, And throw an

00:02:36.080 --> 00:02:41.120
unchecked exception if I do get an error.
I won't retrieve the password until I

00:02:41.120 --> 00:02:45.280
need it, at the time I connect.
This eliminates any concerns about

00:02:45.280 --> 00:02:50.720
it being part of any memory dump, or string pool.
Where I had values hard-coded in the set methods

00:02:50.720 --> 00:02:54.611
on data source in the previous video, I'll
use the values in the props variable.


00:02:55.520 --> 00:03:02.520
I'll create a variable for the datasource.
This is of type My SQL Data source. Instead of

00:03:02.520 --> 00:03:08.160
passing hard coded values, I'll pass the values
that are in the properties object. I can get

00:03:08.160 --> 00:03:14.440
these, using the getProperty method, with the key
name, so here I'll get server name. For the port,

00:03:14.440 --> 00:03:21.440
I'll parse the value to an Integer. And I'll pass
the databaseName in. This is actually optional,

00:03:21.440 --> 00:03:25.600
and I'll show you that in a bit.
Ok, I've got the datasource

00:03:25.600 --> 00:03:29.680
initially set up, now I want to establish
a connection, with my user and password.


00:03:30.960 --> 00:03:34.560
I'll use a try with resources block,
because it's important to close

00:03:34.560 --> 00:03:41.160
database resources, just like file resources.
In the parentheses, I'll use type inference,

00:03:41.160 --> 00:03:45.736
and call getConnection on my datasource.
I'll pass it the user property.

00:03:46.709 --> 00:03:51.840
And I'll pass it the password. This I'll get from
the environment variable directly here,

00:03:51.840 --> 00:03:59.680
by calling system dot get E N V, and pass the name
I used, so my SQL underscore PASS. If you wanted

00:03:59.680 --> 00:04:05.200
to use the password from the properties file, use
get Property. I'll end the try clause on its own

00:04:05.200 --> 00:04:11.248
line, because I'll be adding to the try clause
statements shortly. I'll print Success if this all works.

00:04:12.580 --> 00:04:17.064
Otherwise I'll catch the checked SQL
exception, re-throwing it as a runtime exception.


00:04:19.200 --> 00:04:23.331
I'll run this,
and success.


00:04:24.240 --> 00:04:28.600
I'm connecting to the music database, without
having to enter the username and password,

00:04:28.600 --> 00:04:33.080
which was getting tedious quickly.
This was a quick review of connecting again,

00:04:33.080 --> 00:04:37.956
but I did want to show you this alternative.
It's time to actually get some data now.


00:04:38.760 --> 00:04:42.815
To do this, I can use a statement,
which is an interface type in Java.


00:04:43.640 --> 00:04:48.971
It's implemented by the database vendor in the
JDBC driver, and represents an S Q L statement.


00:04:49.880 --> 00:04:55.480
This can be either DML or DDL.
A statement, once its executed, will return

00:04:55.480 --> 00:05:01.560
the results of the query, in a ResultSet object.
I'll start with a very simple select statement,

00:05:01.560 --> 00:05:05.080
to get all the artists.
I'll set this up as a variable

00:05:05.080 --> 00:05:10.360
before the try with resources statement.
I'll make this a String, named query,

00:05:10.360 --> 00:05:14.153
and type in the S Q L statement I
want executed, as a String literal.


00:05:16.120 --> 00:05:21.600
Here, I'll do Select star from music.artists.
This statement will select all columns,

00:05:21.600 --> 00:05:25.665
and all rows or records from the artists
table in the music database or schema.


00:05:26.680 --> 00:05:29.480
Now, there are a couple of things
here, I just want to point out.


00:05:30.840 --> 00:05:36.000
First, the S Q L commands and clauses in this
statement, are all specified in upper case,

00:05:36.000 --> 00:05:39.360
which is common practice.
In contrast,

00:05:39.360 --> 00:05:45.360
the schema and table name are in lowercase.
Although MySQL is a case-insensitive language,

00:05:45.360 --> 00:05:51.040
some databases are case sensitive, so again it's
best practice to use lowercase for data objects,

00:05:51.040 --> 00:05:55.400
both in naming them and querying them.
Specifying the music schema here isn't

00:05:55.400 --> 00:05:59.480
necessary either, because we've
specified it, in the data resource.


00:06:00.080 --> 00:06:04.373
Even so, you should still make a habit of
including it in your S Q L statement like this.


00:06:05.240 --> 00:06:09.415
It helps with clarity, and may actually
be better performant in some databases.


00:06:10.240 --> 00:06:13.630
To actually run this, I first have
to create a statement object.


00:06:14.560 --> 00:06:17.771
I'll include this, in my
try with resources clause.


00:06:18.680 --> 00:06:20.880
Hopefully you'll remember that
this clause can have multiple

00:06:20.880 --> 00:06:26.560
declarations, separated by a semi colon.
So I'll start by adding that semi colon,

00:06:26.560 --> 00:06:31.427
to the end of the connection statement:
Then I'll add the next declaration, after that.


00:06:32.400 --> 00:06:36.853
I can get a statement instance, by calling
create Statement on the connection instance.


00:06:38.080 --> 00:06:41.800
For a select S Q L statement,
you'll use the executeQuery method,

00:06:41.800 --> 00:06:46.543
to actually execute this query against your
database, which in turn returns a ResultSet.


00:06:47.600 --> 00:06:49.705
First I'll remove the success
statement I had there.


00:06:50.720 --> 00:06:55.120
Instead of that, I'll set up a resultSet
variable, then assign it statement.execute

00:06:55.120 --> 00:07:00.720
Query, passing it my query string.
All three objects, the connection,

00:07:00.720 --> 00:07:05.000
the statement, and the result set are
all resources, that need to be closed.


00:07:05.960 --> 00:07:09.960
I could've included the result set in the
try clause, along with the connection and

00:07:09.960 --> 00:07:15.960
statement, but it's actually not necessary here.
A ResultSet object is automatically closed, when

00:07:15.960 --> 00:07:22.160
the Statement object that generated it is closed.
It's also closed if the statement is re-executed,

00:07:22.160 --> 00:07:26.230
or used to retrieve the next result,
from a sequence of multiple results.


00:07:27.160 --> 00:07:31.288
The ResultSet in this case, will contain
all the records in the artists table.


00:07:32.240 --> 00:07:35.350
To use it, I loop through its
contents, with a while loop.


00:07:36.280 --> 00:07:41.880
Like an iterator, I can check if there's a next
value in the result set. I'll print each record,

00:07:41.880 --> 00:07:46.640
first the artist id, then the artist name.
There are different ways to retrieve the

00:07:46.640 --> 00:07:52.240
column or field data. I can do it by
index, as I'm doing for the artist id,

00:07:52.240 --> 00:07:57.880
so I'll call resultSet.get Int, and pass
it 1. Unlike most software languages,

00:07:57.880 --> 00:08:04.120
SQL starts with 1, as the first index, and
not 0, so 1 will get the first column's data,

00:08:04.120 --> 00:08:10.960
which is an integer value, the artist id here.
Alternately, I can use the field name, so here,

00:08:10.960 --> 00:08:17.480
I'll call getString, and pass artist_name here.
I'll put the closing parentheses on it's own line,

00:08:17.480 --> 00:08:21.790
to support changes later on.
Ok, that's it.


00:08:22.720 --> 00:08:25.758
Let's give this a shot.
I'll run this now.


00:08:28.000 --> 00:08:32.832
This will list all the artists in the table,
in the order of the artist id, as you can see.


00:08:33.720 --> 00:08:38.080
Now this is real success!
I don't know about you, but I always feel

00:08:38.080 --> 00:08:42.670
a sense of accomplishment, getting that first
query to work, in a new database connection.


00:08:43.600 --> 00:08:48.566
I'm communicating with my database, via java
code, and that's pretty empowering really.


00:08:49.560 --> 00:08:54.920
In fact, there are very popular database
management tools, such as Toad, DBeaver,

00:08:54.920 --> 00:08:58.430
and Oracle's SQL Developer,
that have been written in Java.


00:08:59.360 --> 00:09:03.851
These are similar to the MySQL Workbench,
which is actually written in C++.


00:09:04.887 --> 00:09:08.195
You can use any of these tools to
connect to a variety of databases.


00:09:09.400 --> 00:09:13.960
Ok, now let's change this SQL statement, to
get a few records from the view, which was

00:09:13.960 --> 00:09:19.720
named album view, in the music database.
This time I'll limit the data coming back,

00:09:19.720 --> 00:09:23.851
to just a single album namedTapestry,
which I can do with a where clause.


00:09:24.760 --> 00:09:28.880
You can think of a where clause as a
filter, to get a subset of data, based on

00:09:28.880 --> 00:09:35.080
a particular condition, as defined in the clause.
Before the statement that sets the query variable,

00:09:35.080 --> 00:09:40.649
I'll add another variable for the album name.
The album name will be Tapestry, as I said.


00:09:41.960 --> 00:09:43.638
I'll change the query below that,

00:09:43.638 --> 00:09:46.652
and use a formatted string to include album name in the query.

00:09:47.646 --> 00:09:53.571
So first,I'll change the table from artists to album view.
You can query a view just like you would a table.


00:09:54.480 --> 00:09:57.512
I'll add a where clause, so
where album name equals.


00:09:58.400 --> 00:10:01.839
I'll set that to a single
quote, percent s, single quote.


00:10:03.087 --> 00:10:07.120
In ANSI SQL, string literals should be
enclosed in single quotes, when they're

00:10:07.120 --> 00:10:11.600
used in where clauses like this.
I'll be talking about using ANSI SQL

00:10:11.600 --> 00:10:16.560
in a little more detail in a bit.
Double quotes are used to delimit identifiers,

00:10:16.560 --> 00:10:21.080
such as table and column names, which
means these could contain spaces, or other

00:10:21.080 --> 00:10:27.419
characters that aren't allowed in text literals.
Some SQL implementations, including MySQL,

00:10:27.631 --> 00:10:31.954
allow you to use double quotes around text literals,
but I'm going to stick with single quotes.


00:10:32.969 --> 00:10:36.797
I'll use the formatted method on the
string, to pass in the album name variable.


00:10:38.320 --> 00:10:41.720
Because the data coming back will be different
for this view from the artists table,

00:10:41.720 --> 00:10:45.000
I need to change my code in the while
loop, where I'm printing data out.


00:10:45.840 --> 00:10:49.830
I'll add an extra percent s, as a third
element in the string being printed.


00:10:50.760 --> 00:10:56.320
I'll change the code, the getInt argument from
1, or the first column, and use the column name,

00:10:56.320 --> 00:11:00.680
which is track number in this case.
After the artist name get string,

00:11:00.680 --> 00:11:06.472
I'll add a comma, and a new line.
Finally, I'll also include the song title as well.

00:11:08.460 --> 00:11:09.547
If I run this,


00:11:12.000 --> 00:11:15.440
I'll see that Carole King was the artist
for the entire album, and each of the

00:11:15.440 --> 00:11:21.080
songs is listed, by the track number order.
The view itself is ordered by track number,

00:11:21.080 --> 00:11:24.787
which is why I didn't need an order
by clause, in my S Q L statement.


00:11:25.760 --> 00:11:29.240
If you don't know what the data might
be, that's returned from your query,

00:11:29.240 --> 00:11:33.368
you can use the ResultSetMetaData object,
to get information about the ResultSet.


00:11:34.320 --> 00:11:37.760
Let me show you how to do this.
I'll add this code,

00:11:37.760 --> 00:11:42.160
before I execute the result set.
There's a method on the resultSet,

00:11:42.160 --> 00:11:47.200
called get meta data. On that object, I can
get the number of columns that were returned,

00:11:47.200 --> 00:11:52.480
so I'll loop from 1 to this count. For each
column, I'll print the column index, remember

00:11:52.480 --> 00:11:58.720
this starts at 1. I'll print the column name and
its type. I'll pass the appropriate data to that

00:11:58.720 --> 00:12:04.280
printf statement. There are multiple methods on
the result set meta data, and two of these are get

00:12:04.280 --> 00:12:08.333
ColumnName, and get ColumnTypeName, each which
takes a column index.

00:12:09.686 --> 00:12:12.542
I'll include a separator line after this code runs.



00:12:14.699 --> 00:12:15.620
Running this

00:12:18.400 --> 00:12:21.467
You can see information about
the columns, printed out first.


00:12:22.440 --> 00:12:26.331
I can use this information to help facilitate
handling data in a generic fashion.


00:12:27.240 --> 00:12:31.788
I'll show you an example of this next.
I'll remove the code I have in the while loop.


00:12:33.480 --> 00:12:37.825
Before this loop, I'll add a column of
headers, using the result set meta data.


00:12:38.734 --> 00:12:42.216
Again, I'll loop from 1 to the column count,
incrementing by one.

00:12:44.161 --> 00:12:49.811
This time, I'll print each column name, making it left justified,
and allowing for 15 characters.

00:12:50.784 --> 00:12:52.952
I'll also make the column names upper case.

00:12:53.904 --> 00:12:56.977
After the column headers are printed, I'll print a new line here.


00:12:59.000 --> 00:13:01.667
Now, in the while loop,
I'll do something similar.


00:13:02.640 --> 00:13:09.080
Again, I'll loop through the meta data index.
Here, I'll print the resultSet's value,

00:13:09.080 --> 00:13:15.098
using get String, with the meta data index.
After each record, I want a new line.


00:13:16.705 --> 00:13:17.843
Running this,


00:13:20.000 --> 00:13:24.726
I get all the data in a grid, much like I'd see
if I ran that query in the MySQL WorkBench.


00:13:27.200 --> 00:13:31.312
I can use this method for any type of
select query, from any table or view.


00:13:32.200 --> 00:13:36.600
Obviously, 15 characters might not be enough
or the right way to format in every case,

00:13:36.600 --> 00:13:40.720
but you get the idea here.
The result set meta data object,

00:13:40.720 --> 00:13:45.721
has other methods, such as column type and width,
which you can use to make this more flexible.


00:13:46.800 --> 00:13:51.107
Ok, so that's a quick introduction to the
Statement type, using the executeQuery method.


00:13:52.080 --> 00:13:55.368
This method returns the results of
the query in a ResultSet object.


00:13:56.320 --> 00:14:00.832
And you can use the result set meta data object,
to query information about the result set.


00:14:01.720 --> 00:14:04.451
I'll stop this video here,
before it gets too long.


00:14:05.360 --> 00:14:09.280
In the next video, we'll continue to query
the music database using this project,

00:14:09.280 --> 00:14:13.240
and talk about different aspects
of the java.sql.Statement type.
