WEBVTT
Kind: captions
Language: en

00:00:06.720 --> 00:00:11.160
In this challenge, I want you to pick some
text of your choice, from a document you have,

00:00:11.160 --> 00:00:16.500
or an online article, or some wiki page.
You'll create a program to read the text

00:00:16.500 --> 00:00:20.040
document, with one of the methods we talked
about in the last couple of lectures.

00:00:21.120 --> 00:00:24.180
You can pick any method you want
to use, but whichever you use,

00:00:24.180 --> 00:00:28.680
your program should do the following.
Tokenize the text into words,

00:00:28.680 --> 00:00:33.600
remove any punctuation. Ignore
words with 5 characters or less.

00:00:34.680 --> 00:00:39.660
Count the occurrences of each word.
Display the top 10 most used words.

00:00:40.680 --> 00:00:44.220
The point of this exercise is to see if you
can pick out what the article might be about,

00:00:44.220 --> 00:00:46.533
by simply getting the most used words.

00:00:48.232 --> 00:00:50.850
After you use one method, try a second method.

00:00:51.780 --> 00:00:55.320
If you used a method that used a
stream, try some code without using

00:00:55.320 --> 00:01:00.180
a streaming method, or vice versa.
Ok, so go away and give that a try.

00:01:01.260 --> 00:01:05.400
When you're done, and want to see my solutions,
come back and we'll walk through this together.

00:01:07.920 --> 00:01:11.100
Welcome back.
How'd you do on that challenge?

00:01:12.180 --> 00:01:16.020
Were you able to figure it out?
Did you try the bonus part?

00:01:17.100 --> 00:01:20.820
Let's get started.
First, I've created a

00:01:20.820 --> 00:01:24.360
project called ReadingFilesChallenge,
with the usual main class and method.

00:01:25.260 --> 00:01:31.020
Before I write any code, I'll create a new file,
at the root of this project, called article.txt.

00:01:32.160 --> 00:01:36.240
For my article, I've copied the text
from wikipedia, for the Grand Canyon.

00:01:37.200 --> 00:01:41.100
I'll paste it in my file warts and
all, as the saying goes, meaning I'll

00:01:41.100 --> 00:01:45.420
just leave it exactly as I got it.
Now, I'll use a buffered reader,

00:01:45.420 --> 00:01:50.040
because who knows, maybe I'll use this code
against really large text files later on.

00:01:50.880 --> 00:01:56.580
In the try with resources, parentheses, I'll
create a buffered reader variable, just br to

00:01:56.580 --> 00:02:02.460
keep it short, and assign that a new instance of
this class. I'll pass an instance of FileReader,

00:02:02.460 --> 00:02:08.520
using the string literal, article dot text. I'll
add a catch block, because I know I need it.

00:02:09.300 --> 00:02:12.180
If there's an error, I'll just
print it and ignore it after that.

00:02:13.320 --> 00:02:16.620
I'll be using the method lines,
that returns a stream of Strings.

00:02:17.640 --> 00:02:21.180
I'll wrap that in a system dot out print
f statement, because I first want to

00:02:21.180 --> 00:02:25.500
print just the count of lines in the file.
My argument will have the call to the lines

00:02:25.500 --> 00:02:28.288
method, chained to the terminal operation, count.

00:02:29.466 --> 00:02:30.443
Running that

00:02:32.520 --> 00:02:37.680
I'll get that my file has 533 lines in it.
You'll likely get different numbers for this

00:02:37.680 --> 00:02:41.820
if you are on a Mac or running on Linux.
One thing I do want to point out to you,

00:02:41.820 --> 00:02:45.720
while we're looking at this, is what happens
if I try to execute this method again.

00:02:46.680 --> 00:02:49.071
I'll just copy and paste that line of code here.

00:02:50.287 --> 00:02:51.804
If I run the code like this,

00:02:53.700 --> 00:02:58.800
I get 0 lines for the second statement.
After the terminal operation on the first

00:02:58.800 --> 00:03:01.440
pipeline, the file pointer
is at the end of the file.

00:03:02.340 --> 00:03:05.640
I'll be talking about ways to maneuver
this file pointer in a later section,

00:03:05.640 --> 00:03:11.040
through the means of mark and reset methods.
For now, it's important to understand you can't

00:03:11.040 --> 00:03:15.120
use back to back calls like this.
I'll revert that last paste,

00:03:15.120 --> 00:03:17.176
and I'll comment out that first statement.

00:03:17.948 --> 00:03:20.000
Next, I want to count the number of words.

00:03:20.940 --> 00:03:25.680
There's a few ways to do this, but let me show
you one, that uses this lines method again,

00:03:25.680 --> 00:03:30.480
with a regular expression pattern.
First, I'll set up a pattern variable,

00:03:30.480 --> 00:03:35.220
and compile a Pattern, with the string I know the
scanner class uses to split strings into words.

00:03:36.240 --> 00:03:39.540
I'll again set up a print f statement,
this time for the number of words.

00:03:40.560 --> 00:03:46.860
I'll start with my source, lines from the buffered
reader. I'll call flatMap, and use a method on my

00:03:46.860 --> 00:03:52.860
pattern, called splitAsStream. This method will
split the string, and return a stream of String.

00:03:53.820 --> 00:03:59.460
I need flatMap here, to flatten the hierarchy,
before I can use the terminal operation, count.

00:04:00.780 --> 00:04:01.969
If I run this code,

00:04:04.093 --> 00:04:07.445
I'll see that I have 13,799 words in this file.

00:04:08.280 --> 00:04:10.920
Another option, would have
been to split the string.

00:04:11.760 --> 00:04:14.460
I'll comment out this flat map,
and show you another version.

00:04:15.540 --> 00:04:20.220
I have to create a stream here because flat map
only works on a resulting stream, so I'll call

00:04:20.220 --> 00:04:24.540
stream on Arrays, passing it the string array
I get back by using my pattern on each line.

00:04:25.800 --> 00:04:26.580
Running this,

00:04:30.960 --> 00:04:33.540
Instead of a flat map, I could use map and sum.

00:04:34.500 --> 00:04:39.240
I'll copy this entire System.out.printf
statement, and paste a copy just below.

00:04:40.500 --> 00:04:45.360
I'll comment the previous statement out, since I
can't call br dot lines consecutively like this.

00:04:46.320 --> 00:04:49.740
I think it's a good idea to keep
exercising some of these stream skills,

00:04:49.740 --> 00:04:54.060
so I'll just show you this next variation,
in case you find flatMap a little confusing.

00:04:54.960 --> 00:04:59.040
I'll remove that commented out flat map
here, and the two operations below it.

00:05:00.060 --> 00:05:03.060
This time, I'll use mapToLong
as my intermediate operation.

00:05:04.140 --> 00:05:08.040
My lambda expression will still split the
string using the pattern, but this time it

00:05:08.040 --> 00:05:11.915
will return the length of that resulting array.
And instead of count,

00:05:12.012 --> 00:05:14.031
I want the terminaloperation to be sum.

00:05:15.691 --> 00:05:16.764
Running that

00:05:18.840 --> 00:05:22.380
I get the same result, proving
once again, there's no right way.

00:05:23.280 --> 00:05:26.640
This way is probably more efficient,
because there's no overhead with the

00:05:26.640 --> 00:05:30.900
streams, and it's processing a smaller
number of long values, versus strings.

00:05:31.980 --> 00:05:36.720
Ok, I'm going to comment that out again,
Let me get back to the task at hand.

00:05:38.220 --> 00:05:43.020
I'll set up a local variable for my result,
and start out with the source, br dot lines.

00:05:44.100 --> 00:05:47.340
I do want to do a flat map here,
because I want to evaluate every word.

00:05:48.480 --> 00:05:53.280
One of the requirements, was to get rid of
trailing commas and periods, so I'll call map,

00:05:53.280 --> 00:05:58.200
calling replaceAll on the word, using a regular
expression, that stands for any punctuation.

00:05:59.220 --> 00:06:02.760
After this, I only want to evaluate
words with more than 4 characters.

00:06:03.840 --> 00:06:08.160
I'll make all the words lowercase, so I
don't have duplicates, just based on case.

00:06:09.300 --> 00:06:13.800
the terminal operation will group by the whole
word, and count all instances of the same words.

00:06:15.480 --> 00:06:17.160
Now, I need to print out the results,

00:06:17.160 --> 00:06:21.120
and I've said I only want the top 10
words that have the highest frequency.

00:06:22.080 --> 00:06:26.406
I'll stream again, by getting the entrySet of my
result, and calling stream on that.

00:06:27.410 --> 00:06:33.240
I'll sort bythe entry value, which is the count of occurrence,
but I want this to be reversed, so I can pass a

00:06:33.240 --> 00:06:38.467
second comparator, here it's reverseOrder on
Comparator. I'll limit the results to 10.

00:06:39.375 --> 00:06:45.000
And, I'll print this information, first the key
(the word), and then, the number of occurences.

00:06:46.860 --> 00:06:52.200
Ok, I'll run this, and see what might be some of
the most important words, about the Grand Canyon.

00:06:53.100 --> 00:06:58.080
Not surprisingly, canyon and grand are at the
top, but I've got national and river and colorado.

00:06:59.340 --> 00:07:02.220
Some of these words look like
they're more geared to wikipedia,

00:07:02.220 --> 00:07:08.460
like retrieved, and original, and service maybe.
I can create a list of words I want to exclude.

00:07:09.480 --> 00:07:13.740
I'll do that next.
I'll just set up a list of excluded words here.

00:07:14.640 --> 00:07:22.380
so grand, canyon, retrieved and archived.
and maybe service and original too.

00:07:25.560 --> 00:07:29.940
I'll need to filter out the excluded words, and
I can do that by checking if the list contains

00:07:29.940 --> 00:07:34.680
the word, and if it does, I'll return
false, so the word won't be included.

00:07:35.700 --> 00:07:37.440
Ok, now if I run this,

00:07:39.600 --> 00:07:44.520
I get some other descriptive words, so national,
likely because it's a national park in the U.S.

00:07:45.720 --> 00:07:49.860
River and Colorado, because the canyon
was carved out by the Colorado River.

00:07:50.760 --> 00:07:53.280
Water is a really big deal
for this canyon and river,

00:07:53.280 --> 00:07:57.480
so it's not surprising that's there, and
arizona is the state it's located in.

00:07:58.380 --> 00:08:01.200
So that's a nice snapshot of
the article in 10 words or less.

00:08:02.340 --> 00:08:05.100
I'll try another example,
this time I'll use big ben.

00:08:06.120 --> 00:08:10.709
I'll copy this text from the file in the
resources folder, called big ben dot txt.

00:08:11.520 --> 00:08:13.440
I again want this at the root of the folder.

00:08:21.480 --> 00:08:25.260
I'll change my code, so that I'm
pointing at the bigben.txt file.

00:08:26.160 --> 00:08:27.238
I'll run that.

00:08:29.238 --> 00:08:31.238
If you didn't know anything about Big Ben,

00:08:31.238 --> 00:08:35.820
you might guess that it has something to do with
a clock tower, in london, and that it has bells.

00:08:36.660 --> 00:08:40.320
I don't know what the different months are
all about, so maybe I could add those to the

00:08:40.320 --> 00:08:44.580
excluded words, but anyway you can kind of
get the gist of this topic, in a few words.

00:08:45.720 --> 00:08:48.780
Ok, so the bonus part of this
was to do this with a stream,

00:08:48.780 --> 00:08:52.740
and then without, or vice versa, so
I'll do this without a stream next.

00:08:53.820 --> 00:08:58.020
I'll use readString on Files.
First I'll add a separator line.

00:08:59.400 --> 00:09:02.940
I'll then create a string variable,
input, assigning it what I get back

00:09:02.940 --> 00:09:06.780
from Files dot read string, and I'll
pass that a Path for the big ben file.

00:09:07.680 --> 00:09:12.600
I can replace all punctuation in the entire
String, with one call, so that's kind of nice.

00:09:13.920 --> 00:09:19.080
I've got a compiler error on readString, and
it's the IO Exception, so I'll add a try catch.

00:09:21.540 --> 00:09:24.300
I'll just move that last input
statement into the try block.

00:09:25.680 --> 00:09:27.570
Next, I'll set up my pattern.

00:09:28.439 --> 00:09:31.818
This is going to be different,
because I'm not splitting or tokenizing.

00:09:32.640 --> 00:09:35.040
I'll use Matcher to find all
the words in this big string.

00:09:36.000 --> 00:09:38.220
My pattern will look for
one or more word characters.

00:09:39.720 --> 00:09:43.200
I'll get a Matcher, passing the matcher
method all the text from my file.

00:09:44.100 --> 00:09:48.180
I'll set up a new map manually, keyed
by string, containing a long value.

00:09:49.256 --> 00:09:53.640
Next, I'm going to use matcher's find method to
loop through each match, or each word it found.

00:09:54.720 --> 00:09:58.380
I can use matcher dot group to get the
next word, and make that lower case.

00:09:59.400 --> 00:10:02.983
I'll check the length, making sure it's
greater than 4 characters.

00:10:03.852 --> 00:10:09.380
I'll use merge,putting 1 as the first value, and incrementing
by that, if it's not a new keyed entry.

00:10:10.500 --> 00:10:16.080
That'll populate my map with distinct values,
and counts, so next I'll sort this, and print it.

00:10:16.860 --> 00:10:19.669
I'll first create an array list, of the entries.

00:10:20.634 --> 00:10:24.005
I'll sort the entries, by the value, in reverse.

00:10:25.980 --> 00:10:29.520
I'll loop from 0 to 9, or less if
the text doesn't have 10 entries.

00:10:31.260 --> 00:10:35.910
I'll get the entry from the list.
I'll print it as I did before

00:10:38.700 --> 00:10:41.391
Ok, that's it, and I can now give that a shot.

00:10:43.391 --> 00:10:46.044
In this code, I didn't exclude any words,

00:10:46.044 --> 00:10:50.820
but you can see the counts for clock and tower are
the same, and so on, so this code is also working.

00:10:52.035 --> 00:10:56.160
I could also have included that check for
5 characters, in my regular expression.

00:10:57.234 --> 00:11:01.200
I can do that with curly braces, then
5 comma, which says I want at least

00:11:01.200 --> 00:11:06.060
5 word characters, but I'll take more.
I can comment out that if statement now,

00:11:06.060 --> 00:11:09.600
around the merge.
Running that,

00:11:13.200 --> 00:11:17.280
I'll get the same results.
I could have also just used the method

00:11:17.280 --> 00:11:21.780
on matcher that returns a stream of matches, but
the challenge was to use a streamless option.

00:11:22.740 --> 00:11:25.080
Ok, so I hope you got a lot out of that exercise.

00:11:26.280 --> 00:11:28.620
Maybe you came up with several
different ways to do this.

00:11:29.700 --> 00:11:33.720
Think about posting your solutions in the
Q&amp;A, it would be kind of fun to see how

00:11:33.720 --> 00:11:37.380
many different variations you guys all came
up with, because there's probably a ton.

00:11:38.400 --> 00:11:42.600
Again, there's not a really wrong solution,
some might perform better than others,

00:11:42.600 --> 00:11:47.280
but with small files, you don't have to get
too concerned about the details of performance.

00:11:48.300 --> 00:11:52.560
In the next video, I'll start talking about
writing files, so I'll see you in that video.
