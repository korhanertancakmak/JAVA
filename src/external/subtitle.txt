WEBVTT
Kind: captions
Language: en

00:00:06.960 --> 00:00:12.240
The bonus part of this challenge was to create a
second method on song query, that uses a criteria

00:00:12.240 --> 00:00:18.000
builder query, to produce the same results.
I gave you a hint to use the multiselect method

00:00:18.000 --> 00:00:21.720
and to research the join method,
on root to perform your joins.

00:00:21.720 --> 00:00:29.200
So let's jump right into some code for this.
I've still got the JPA project open and the class

00:00:29.200 --> 00:00:34.840
I created in the last video called song query.
Instead of cutting and pasting a method from

00:00:34.840 --> 00:00:40.280
the main query class as I did with the JPQL
method I'll create this method from scratch.

00:00:40.280 --> 00:00:44.720
I'll start with a private static method that
returns a list, but this time, I'm going to have

00:00:44.720 --> 00:00:49.760
it return a list of object array. I'll call
it get matched songs builder, and the first

00:00:49.760 --> 00:00:56.120
parameter will be entity manager, just as before.
The second parameter will be the string, matched

00:00:56.120 --> 00:01:02.640
value. The next thing I need to do is get the
criteria builder instance. I'll call it builder

00:01:02.640 --> 00:01:09.440
to save a little space and I get that instance by
calling entity manager dot get criteria builder.

00:01:09.440 --> 00:01:14.480
From that I can get a criteria query instance.
This will be typed to the object array. I'll

00:01:14.480 --> 00:01:19.400
call it query and that's equal to builder dot
create query. Instead of artist dot class I

00:01:19.400 --> 00:01:22.058
pass the object array dot class declaration.

00:01:24.801 --> 00:01:27.160
So why am I returning an array of objects?

00:01:27.160 --> 00:01:32.800
Instead of returning every matching artist with
all the albums and songs associated to the artist,

00:01:32.800 --> 00:01:38.040
this method will simply return the song
title, the artist name and the album name

00:01:38.040 --> 00:01:43.040
as objects in an object array, which will
make processing the results a lot simpler.

00:01:43.040 --> 00:01:48.680
This also lets me show you how to select
a specific column, using criteria query.

00:01:48.680 --> 00:01:53.920
Next I get the root, which still ultimately be the
artist class. I don't really need artist except I

00:01:53.920 --> 00:02:00.600
do want to get the artist name, so in this case I
need all three entities. I join albums to artist

00:02:00.600 --> 00:02:06.920
by creating a join variable, typed with artist,
and album. I'll call this album join and I can

00:02:06.920 --> 00:02:12.760
get this by calling root dot join, passing
albums, the field name on my Artist entity,

00:02:12.760 --> 00:02:18.640
and specifying a join type. In this case the
join type is inner. The join type class is

00:02:18.640 --> 00:02:23.880
just a simple enum, with inner, left, and right as
your options. left and right are different types

00:02:23.880 --> 00:02:29.560
of outer joins. I'll do something very similar
on this next line creating another join type,

00:02:29.560 --> 00:02:34.800
this time with album and song, which I'll call
song join, and I get that from the album join

00:02:34.800 --> 00:02:42.560
variable this time not the root. I pass the field
name, playlist, and again I want an inner join.

00:02:42.560 --> 00:02:47.280
Now that I have my root and joins set up I
can start chaining methods on my criteria

00:02:47.280 --> 00:02:53.920
query variable, which here I've called query.
I first call multiselect rather than select,

00:02:53.920 --> 00:02:56.357
which lets me pass a var args list of values.

00:02:57.460 --> 00:03:00.400
I'll select the artist name from the root.

00:03:00.400 --> 00:03:06.122
Then I'll select the album name for the album
join variable. Finally, I can select song title

00:03:06.122 --> 00:03:07.786
from the song join variable.

00:03:09.000 --> 00:03:12.602
I'll chain a call
to the where method next. Here I use criteria

00:03:12.602 --> 00:03:19.040
builder to get my like component. I'll pass that
a song title from the song join variable and then

00:03:19.040 --> 00:03:25.200
matched value. This sets up the like clause.
Next, I'll chain the order by method because

00:03:25.200 --> 00:03:31.400
I want this data sorted by artist name. I get
an order instance by calling the method A S C,

00:03:31.400 --> 00:03:36.280
on the builder, then pass the field I want
the data sorted by, so root dot get artist

00:03:36.280 --> 00:03:38.901
name. This sets up the order by clause.

00:03:40.285 --> 00:03:43.256
I'll useentity manager to create a typed query passing

00:03:43.256 --> 00:03:49.360
it the criteria query instance, and I'll chain
get Result List to that which is then returned.

00:03:49.360 --> 00:03:51.632
To test this I'll scroll up to the main method.

00:03:53.604 --> 00:03:55.684
First I'll copy the two print f statements that

00:03:55.684 --> 00:03:57.343
printed my formatted headers.

00:03:58.702 --> 00:04:01.036
I'll paste that before the main method's catch clause.

00:04:04.266 --> 00:04:07.560
Next I'll set up a variable for the results.

00:04:07.560 --> 00:04:13.280
I'll use var for simplicity, and call the variable
b matches, setting that equal to get matched Songs

00:04:13.280 --> 00:04:16.548
builder, first passing the entity manager
variable.

00:04:17.577 --> 00:04:21.237
Here again I'll pass the string that's used
by the like clause as the secondargument.

00:04:22.315 --> 00:04:24.803
This time I can just call for Each
on the list I got back.

00:04:25.881 --> 00:04:30.560
I'll use the formatted
string I used previously. I'll use the indices,

00:04:30.560 --> 00:04:35.760
0 through 2, to get each object from
the array in the list and cast each to a

00:04:35.760 --> 00:04:41.920
string. And that's all I need to do this time.
Before I run this, I'll scroll up a bit and

00:04:41.920 --> 00:04:47.360
change the word variable to a different
value, so from Storm to Soul there.

00:04:47.360 --> 00:04:48.534
I'll run this code.

00:04:50.811 --> 00:04:53.108
Both queries will print the same output,

00:04:53.108 --> 00:04:57.640
though the first isn't sorted by artist.
The method to get the data was quite

00:04:57.640 --> 00:05:02.040
different in these two cases.
The first used a JPQL query with

00:05:02.040 --> 00:05:07.280
joins defined in the string literal.
The entire artist entity was returned,

00:05:07.280 --> 00:05:14.880
every album and every song, if a song
was found on any album for the artist.

00:05:14.880 --> 00:05:20.360
In the second example I use Criteria
Builder and Criteria Query to build up

00:05:20.360 --> 00:05:24.600
a query with object instances.
I select only the columns I'm

00:05:24.600 --> 00:05:29.640
interested in and Pass back a list,
where each element is an object array.

00:05:30.400 --> 00:05:34.440
Ok, so I hope you got a lot out of that challenge.
There are a lot of different ways you could have

00:05:34.440 --> 00:05:37.680
coded this but I did want to
show you these alternatives.

00:05:37.680 --> 00:05:41.200
So this ends the section on
working with databases in java.

00:05:41.200 --> 00:05:45.720
In the next section I'll be covering networking,
so congratulations on completing this section and

00:05:45.720 --> 00:05:48.960
now let's move on to a new topic.
I'll see you in the next video.
