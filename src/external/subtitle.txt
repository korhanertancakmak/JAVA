WEBVTT
Kind: captions
Language: en

00:00:05.320 --> 00:00:09.349
In this video, I'm picking up where I left
off, in the PreparedStatement project.


00:00:10.240 --> 00:00:13.946
I've created methods to add an
artist, add an album, and add a song.

00:00:14.880 --> 00:00:19.640
Each method takes a prepared statement.
I'm not creating the prepared statement,

00:00:19.640 --> 00:00:24.880
in any of these methods, because they
may be called multiple times. Instead,

00:00:24.880 --> 00:00:30.360
I'm passing a prepared statement to each method.
To execute these, I'll create a method,

00:00:30.360 --> 00:00:36.116
that will loop through the records in my csv
file, determining when each needs to be called, and executing them.

00:00:37.094 --> 00:00:41.184
I'll call this method, addData From file,
and that'll take an open connection,

00:00:41.184 --> 00:00:42.950
and throw an SQL exception.


00:00:44.080 --> 00:00:49.880
I'll set a variable for the records in the file,
so a list of string. I'll need a try catch,

00:00:49.880 --> 00:00:55.200
Because I'll be calling readAllLines on the
Files class. I'll pass it the path of my file,

00:00:55.200 --> 00:01:02.480
which is in the working directory. And it's named
New Albums.csv. If an IO Exception is thrown,

00:01:02.480 --> 00:01:04.666
I'll throw a runtime exception instead.

00:01:07.274 --> 00:01:10.621
After this, I'll have a list of records,
which are comma delimited.

00:01:11.685 --> 00:01:13.575
I'll set up some local variables next.


00:01:14.640 --> 00:01:19.089
I'll initialize lastAlbum to null, and the same
with a variable named last Artist.

00:01:20.132 --> 00:01:25.172
I'll check these variables to determine if a new album
or new artist is indicated in the file.

00:01:26.150 --> 00:01:32.256
The file has grouped the artist, there's only one,
Bob Dylan, and it's grouped the 2 album's song titles.

00:01:33.190 --> 00:01:39.920
I'll initialize the artist id to minus
And the same for album id. Next, I'll set up

00:01:39.920 --> 00:01:45.400
a try with resources block, and in the try clause,
I'll get prepared statements for each of my insert

00:01:45.400 --> 00:01:53.120
queries. The first I'll call PS Artist. Because I
want the generated key back, I can pass the RETURN

00:01:53.120 --> 00:01:59.800
GENERATED KEYS to the prepareStatement method,
as a second argument. Next, I've got PS Album,

00:01:59.800 --> 00:02:05.160
for the album insert statement, and again
I'll pass that constant. The last prepared

00:02:05.160 --> 00:02:09.593
statement is for the insert song code, and
again I'll want the auto generated key back.

00:02:10.680 --> 00:02:15.758
I'll leave the try block empty for the moment.
I'll complete the try with a catch clause.

00:02:16.845 --> 00:02:22.040
Here, I'll call the rollback method on a connection if
something throws an error. And I'll propagate the

00:02:22.040 --> 00:02:28.120
error up, but as a runtime exception
In the try clause, the first thing

00:02:28.120 --> 00:02:32.960
I want to do is turn off auto commit.
I do that by passing false, to the set

00:02:32.960 --> 00:02:37.818
Auto Commit method on connection. I'll loop
through the records I got from the file.

00:02:39.491 --> 00:02:45.840
I'll split each record into columns, using the comma as
a delimiter. I only want to insert an artist once,

00:02:45.840 --> 00:02:51.440
so I'll check if the artist name has changed or if
it's null. If either of these conditions was met,

00:02:51.440 --> 00:02:56.062
then I'll set the last artist to the value in the
first column, which is the artist name in my file.

00:02:57.040 --> 00:03:02.800
I'm assuming here that these are all new artists,
for simplicity's sake. And I'll execute my method,

00:03:02.800 --> 00:03:08.520
add artist, passing it my prepared Statement, the
connection and the artist name. I'll do the same

00:03:08.520 --> 00:03:14.920
thing for album name, so it will only get inserted
once, when the value of last Album changes. album

00:03:14.920 --> 00:03:20.640
name is in the second column, in my file Then
I'll call my add album method, passing the album

00:03:20.640 --> 00:03:26.280
prepared statement, the connection, the artist id
I got when I called add Artist, and the lastAlbum,

00:03:26.280 --> 00:03:33.000
which should have the value of the new album to be
added. This method returns the album id. Finally,

00:03:33.000 --> 00:03:38.040
each record represents a song on the album.
so I'll call add Song for every record,

00:03:38.040 --> 00:03:42.520
passing the prepared statement for the song
S Q L, the connection, the album id I got

00:03:42.520 --> 00:03:47.640
back from adding the last album, The last two
arguments are the track number, and song title,

00:03:47.640 --> 00:03:52.400
which are my third and fourth columns in
the csv file. If all of these statements

00:03:52.400 --> 00:03:57.744
executed successfully, I'll call commit.
And I'll set auto commit back to true.


00:03:59.200 --> 00:04:02.184
Finally, I'll just call this last
method from the main method.


00:04:05.400 --> 00:04:10.280
I'll call this method first, passing it the
current connection. I want to see the data

00:04:10.280 --> 00:04:14.360
we get back from the view after the execution
of this method, so that's why I put it here,

00:04:14.360 --> 00:04:18.320
before the select code below.
I'll update the parameter for the

00:04:18.320 --> 00:04:22.391
prepared statement I use to select data,
making that Bob Dylan instead of Elf.


00:04:23.760 --> 00:04:25.765
I'll run this code and see what happens.


00:04:29.720 --> 00:04:32.915
First, I can see a series of statements
with IDs printed,

00:04:32.915 --> 00:04:36.644
these don't include the
type, but I can guess, by their order.


00:04:37.600 --> 00:04:42.992
At the start, there's the artist, then the album,
then followed by a series of song inserts.


00:04:43.840 --> 00:04:47.014
You can see the consecutive numbers
listed for the song inserts.


00:04:47.840 --> 00:04:52.247
And after this code runs, you can see all the data
from the select from the album view was printed.


00:04:53.160 --> 00:04:56.880
Even though I'm not using batch processing
here, I've still been able to take advantage

00:04:56.880 --> 00:05:02.520
of the prepared statement's precompiled feature.
This means the execution of each of these queries,

00:05:02.520 --> 00:05:05.127
should be much faster than if
I had just used a statement.


00:05:06.040 --> 00:05:10.974
But I'm still making a round trip to the database
server, so about 30 round trips in this case.


00:05:11.800 --> 00:05:16.560
Let's add batch processing to this code.
Because I need to retrieve the automatically

00:05:16.560 --> 00:05:20.506
generated artist id and album id,
I can't batch these statements.


00:05:21.440 --> 00:05:25.422
But I can batch up the song insert
records, for a little more efficiency.


00:05:26.291 --> 00:05:31.640
Before I do this, I'll open up SQL Work
bench, and change the album and songs tables,

00:05:31.640 --> 00:05:37.182
to allow cascade deletes, and then we'll delete
all this data for Bob Dylan, before we re-run.


00:05:39.160 --> 00:05:44.200
So open My SQL Workbench for your dev user.
Make sure you have the schemas tab open

00:05:44.200 --> 00:05:49.623
in the left panel, and highlight albums.
Click the tool or wrench icon to the right.


00:05:50.840 --> 00:05:56.159
Look for a series of tabs below the form.
Select the Foreign Keys tab.


00:05:56.920 --> 00:06:02.720
On this screen, highlight FK ARTIST ID.
This lists the columns, and any referenced

00:06:02.720 --> 00:06:06.214
column, so you can see artist id
does have a referenced column.


00:06:07.040 --> 00:06:10.091
On the furthest right panel,
are some foreign key options.


00:06:10.960 --> 00:06:16.660
You can see that on Delete, it's set to restrict.
I'll change this to CASCADE from the drop down.


00:06:17.920 --> 00:06:22.280
I'll select the Apply button.
This will display the DDL Script that

00:06:22.280 --> 00:06:26.540
gets run to effect this change.
I'll select APPLY next.


00:06:27.800 --> 00:06:31.891
I should get a message that the SQL script
was successfully applied to the database.


00:06:32.760 --> 00:06:36.909
I'll select Finish, and I'll go through the
same series of steps for the songs table.


00:06:37.800 --> 00:06:42.960
So I'll select songs, and click the wrench icon.
That pops up a tab,

00:06:42.960 --> 00:06:47.749
and I'll select foreign keys again.
I'll highlight FK ALBUM ID this time.


00:06:48.640 --> 00:06:51.607
I'll change the value of the On Delete
option from RESTRICT to CASCADE.


00:06:52.520 --> 00:06:56.299
I'll again hit the Apply button.
I'll hit the next apply button.


00:06:57.320 --> 00:06:59.360
And finally the finish button.

00:07:00.603 --> 00:07:02.964
To test this, I'll open a query tab.


00:07:03.920 --> 00:07:06.426
This is the first icon
under the top menu listing.


00:07:07.360 --> 00:07:13.993
First let's query the view for Bob Dylan data.
Executing this statement with the lightning bolt,

00:07:15.080 --> 00:07:18.963
I should get the same information my
java code listed in the last execution.


00:07:24.200 --> 00:07:30.200
Now I'll delete the artist Bob Dylan.
If I set my cursor directly before

00:07:30.200 --> 00:07:33.840
the word delete, I can run just this
statement, by selecting the lightning

00:07:33.840 --> 00:07:40.360
bolt icon, with an eye over the top of it.
You can see at the bottom of the screen I

00:07:40.360 --> 00:07:46.840
get Error Code 1175 - You are using Safe mode.
This is a built in MySQL Workbench feature that

00:07:46.840 --> 00:07:52.775
prevents you doing an entire table deletion.
It's a useful feature to prevent a potential disaster.

00:07:53.732 --> 00:07:57.391
You often do not want to delete an
entire tables contents, after all.

00:07:58.107 --> 00:08:03.198
But here, we do want to do that.
I need to go into preferences and turn off this feature.

00:08:04.133 --> 00:08:06.229
So I'll clickEdit and select Preferences.

00:08:08.359 --> 00:08:10.000
 I'll then click SQL Editor.

00:08:10.814 --> 00:08:14.020
And turn off this safe guard
by unchecking the Safe Updates box.

00:08:15.000 --> 00:08:19.160
 Note that it protects both deletes and updates
of an entire table. Which happens when we

00:08:19.160 --> 00:08:25.000
do not filtering the SQL Statement in some
way. As is the case here. I'll click OK.


00:08:25.760 --> 00:08:30.752
I'll re-run the sql delete code
again, and, I get the same error.


00:08:31.600 --> 00:08:36.865
I'll try a refresh but I think I have to restart
MySQL Workbench for this change to take effect.


00:08:37.560 --> 00:08:41.025
I'll reexecute the select again,
just to see if that works.


00:08:44.480 --> 00:08:49.073
I'm still getting the same error, so I'll
close down and re-start MySQL Workbench.


00:09:00.000 --> 00:09:03.696
Right, so let's try the select and delete again.

00:09:12.085 --> 00:09:16.019
Success, finally. We don't get any errors.


00:09:16.880 --> 00:09:20.498
Without the cascade delete, I would
have gotten errors trying to do this.


00:09:21.280 --> 00:09:25.992
I'll set my cursor before the select keyword,
and again click the execute inline icon.


00:09:26.840 --> 00:09:30.112
This executes the select against
the view, and now I have no data.


00:09:30.960 --> 00:09:36.832
So my single delete statement, deleted two
related albums, as well as 27 related songs.


00:09:37.680 --> 00:09:41.520
I'll jump back to IntelliJ, and
I'll make some changes to this code,

00:09:41.520 --> 00:09:47.255
to support batching up all the song records.
I'll start with the addSong method.


00:09:48.233 --> 00:09:51.139
First, I'll make the return
type void, and not int.


00:09:52.160 --> 00:09:55.494
Then I'll remove the first statement,
where I initialize song ID.


00:09:56.320 --> 00:09:59.120
I'll remove the entire if statement,
and all the statements in there.


00:10:00.160 --> 00:10:03.780
I don't need to get the song IDs for
my code, so I'll remove all these.


00:10:05.040 --> 00:10:11.400
Finally, I'll remove the return statement.
Next, I'll remove the execute update method call,

00:10:11.400 --> 00:10:16.651
since we are batching the addition of the songs.
I'll execute add Batch on the prepared statement.


00:10:18.368 --> 00:10:23.568
Again, add batch won't execute anything, it just
populates a list of statements that will be run,

00:10:23.720 --> 00:10:28.720
when the executeBatch method gets called.
I'll go back to the addData From File method,

00:10:28.720 --> 00:10:32.124
and scroll down, to just before
the commit statement I make.


00:10:32.971 --> 00:10:37.625
Here, I'll be executing all the queued up
statements, on the PS Songs prepared statement.


00:10:38.560 --> 00:10:42.861
Each statement returns the number of records
effected, returned as an int array there.


00:10:43.730 --> 00:10:49.440
I'll set up an int array variable called inserts,
and then execute batch. If everything worked

00:10:49.440 --> 00:10:53.320
perfectly, the inserts length should
be the number of records inserted,

00:10:53.320 --> 00:10:58.160
but it's possible a count could be zero, if
something went wrong. I'll create a total

00:10:58.160 --> 00:11:05.240
inserts variable. I'll set up a mini stream here,
with Arrays.stream, passing it the inserts array,

00:11:05.240 --> 00:11:10.000
and then terminating with the sum operation.
This quickly sums all this data.

00:11:10.925 --> 00:11:12.425
I'll print this information out.



00:11:15.490 --> 00:11:16.838
And I'll run this again.

00:11:20.640 --> 00:11:25.134
My first three statements of output are
the artist id, and the 2 new album IDs.


00:11:25.960 --> 00:11:29.600
Then I get the statement that 27 songs
were inserted, this was done with

00:11:29.600 --> 00:11:33.840
one trip to the database server.
And then I can see from the view,

00:11:33.840 --> 00:11:37.280
the records are all there.
Anytime you're executing a

00:11:37.280 --> 00:11:42.400
series of statements, whose only difference is
column values, as was the case in this code,

00:11:42.400 --> 00:11:44.227
you should use a prepared statement.

00:11:46.118 --> 00:11:48.879
The PreparedStatement has many advantages over the Statement.

00:11:49.856 --> 00:11:51.720
Pre-compilation involves parsing,

00:11:51.720 --> 00:11:56.840
optimizing, and storing the SQL statement, in
a format that can be efficiently executed by

00:11:56.840 --> 00:12:02.946
the database server. This process occurs only
once, making subsequent executions faster.


00:12:03.880 --> 00:12:08.720
Parameterized Queries are supported with
placeholders. These are identified as

00:12:08.720 --> 00:12:13.560
question marks in the S Q L string.
They're used for dynamic data values,

00:12:13.560 --> 00:12:19.360
and get replaced with actual values at runtime.
These help prevent SQL injection attacks,

00:12:19.360 --> 00:12:25.419
by separating SQL code, from user input.
Another advantage is Efficient Reuse.

00:12:26.331 --> 00:12:31.440
A PreparedStatement can be used multiple times,
executing the same or similar SQL statements

00:12:31.440 --> 00:12:38.680
with different parameter values. This results in
improved performance. With parameterized queries,

00:12:38.680 --> 00:12:44.160
we get Automatic Type Conversion.This meansA
PreparedStatement handles the conversion,

00:12:44.160 --> 00:12:50.640
between Java and SQL data types, ensuring data
compatibility. Using Prepared statements help

00:12:50.640 --> 00:12:55.520
with Readability and Maintainability.Code
that uses PreparedStatements is easier to

00:12:55.520 --> 00:13:00.440
read and understand, than looking at a series
of concatenated SQL strings with user input,

00:13:00.440 --> 00:13:07.019
for example.A PreparedStatement also provides
Type Safety when binding parameters to SQL statements.

00:13:08.040 --> 00:13:13.138
This helps avoid data type mismatches,
that lead to runtime errors or data corruption.


00:13:13.920 --> 00:13:18.640
With all of that being said, our insert code
still has a couple of major flaws, because of

00:13:18.640 --> 00:13:23.647
the very nature of having to execute up to three
insert statements, for a single song in an album.


00:13:24.560 --> 00:13:30.320
I wasn't able to batch the entire process.
So if I had 1000 new albums, and 1000 new

00:13:30.320 --> 00:13:34.011
artists, I'd still be doing 2000
round trips to the database.


00:13:34.880 --> 00:13:39.120
If a problem occurred inserting the second
album, none of the song titles for the first

00:13:39.120 --> 00:13:42.407
album would have been inserted,
because of the way I coded this.


00:13:43.320 --> 00:13:46.760
In the next video, I'll demonstrate
how to address some of these problems,

00:13:46.760 --> 00:13:51.040
with something called a stored procedure.
You can think of this as a method on the

00:13:51.040 --> 00:13:55.320
database server, we can access.
But before I get into that,

00:13:55.320 --> 00:13:59.282
I've got another challenge for you.
So I'll see you in that next video.
