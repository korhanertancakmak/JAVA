WEBVTT
Kind: captions
Language: en

00:00:05.160 --> 00:00:10.200
Up until now, I've used JPA to map a database
record to a special type of object, called an

00:00:10.200 --> 00:00:16.000
entity, using Hibernate as the JPA Provider.
This was great, when working with a single

00:00:16.000 --> 00:00:21.240
targeted record, and it's associated data.
You'll probably at some point still need to

00:00:21.240 --> 00:00:28.200
query the database, for a set of records.
To do this, you can use a JPA query.

00:00:28.200 --> 00:00:32.960
You know by now that a query in the database,
is often a select statement of some kind, but

00:00:32.960 --> 00:00:40.040
can also be an update, insert or delete statement.
In JPA, you have three options to execute a query,

00:00:40.040 --> 00:00:43.840
all of which still rely on the
existence of an entity class.

00:00:43.840 --> 00:00:50.680
You can use a JPA Query, using a special query
language, named JPQL. There's something called a

00:00:50.680 --> 00:00:57.000
Criteria Builder, which is a more programmatic way
to put together the selection request. ; Finally,

00:00:57.000 --> 00:01:00.480
if you're comfortable in SQL, or
maybe you have a special need,

00:01:00.480 --> 00:01:07.920
to increase performance for example, you can
still use a Native Query, which relies on SQL.

00:01:07.920 --> 00:01:14.360
The Java Persistence Query Language, or
JPQL, is an object-oriented query language.

00:01:14.360 --> 00:01:20.040
It's specifically designed to work with
entities, in Java applications that use JPA.

00:01:20.040 --> 00:01:23.480
It provides a way to query data
stored in relational databases,

00:01:23.480 --> 00:01:28.600
without needing to understand the details,
of how the data is actually structured there.

00:01:28.600 --> 00:01:36.240
Let's start by looking at JPQL, in some code.
I'll be using the same project from the last

00:01:36.240 --> 00:01:40.320
couple of lectures, so I've
got the JPA Project open.

00:01:40.320 --> 00:01:44.720
Using this project means, I can continue
to use the entities, Artist and Album,

00:01:44.720 --> 00:01:49.040
that I set up previously.
To use JPQL, you actually

00:01:49.040 --> 00:01:56.080
query entities, and not tables specifically.
I'll create a new class, in the dev lpa package,

00:01:56.080 --> 00:02:03.840
and I'll call this class, MainQuery.
I'll include a main method,

00:02:03.840 --> 00:02:07.880
using the PSVM shortcut.
Before I add any code to the

00:02:07.880 --> 00:02:14.080
main method in this class, I'll first create
a private static method, also in this class.

00:02:14.080 --> 00:02:19.040
This method is going to return a List of
Artist entity types, based on some query.

00:02:19.040 --> 00:02:23.840
So I'll start with private, static, then
List, with Artist declared in angle brackets,

00:02:23.840 --> 00:02:29.760
so my List will only have artist entities in it.
I'll name this method get Artists JPQL.

00:02:29.760 --> 00:02:35.240
It will have two parameters. First, an
EntityManager, which I'll be creating

00:02:35.240 --> 00:02:41.240
and managing, in the main method, and passing
to this method. I'll also include a string,

00:02:41.240 --> 00:02:48.200
which I'll call matchedValue. So next, I'll create
a variable, a string for my query statement. I'll

00:02:48.200 --> 00:02:56.960
call this JPQL, and I'll set that to a string
literal. Select a, from artist, a. This looks

00:02:56.960 --> 00:03:04.840
a lot like SQL. The letter a, in this case is a
variable, as well as a table alias. Notice that

00:03:04.840 --> 00:03:12.360
I'm selecting, not from artists, or music.artists,
so not from the table name. Instead, I select from

00:03:12.360 --> 00:03:19.960
Artist, with a capital A, which actually refers to
my Artist entity, the Artist class in other words.

00:03:19.960 --> 00:03:24.000
I can execute this query, using
a method on the EntityManager.

00:03:24.000 --> 00:03:29.480
I'll use Local Variable type inference, to set up
the next variable, so var as the type, and query

00:03:29.480 --> 00:03:35.120
as the variable name. I'll make that equal to the
value I get back, when I execute createQuery on

00:03:35.120 --> 00:03:41.000
the EM method argument, which is really an Entity
manager. This method takes two arguments, first

00:03:41.000 --> 00:03:48.000
is a string, that contains JPQL, so I'll pass my
variable for that. The second argument specifies

00:03:48.000 --> 00:03:54.800
the class name, of the entity that's being
queried, so here, I need to pass Artist.class.

00:03:54.800 --> 00:04:01.280
Finally, the query object I get back, has a
method called getResultList on it. In this case,

00:04:01.280 --> 00:04:07.360
it'll return a List of Artists, so I can just
return that directly here, from this method.

00:04:07.360 --> 00:04:10.000
And that's it.
These three lines

00:04:10.000 --> 00:04:15.280
of code will get all the artists, from
the music schema, from the artists table.

00:04:15.280 --> 00:04:19.160
Before I run this, notice,
from Intelli J's inlay hint,

00:04:19.160 --> 00:04:26.080
the type that's inferred, for the query variable.
It's a TypedQuery, a generic type, an interface in

00:04:26.080 --> 00:04:32.680
this case, that has a type argument of Artist.
I can control click on that hint.

00:04:32.680 --> 00:04:36.760
This opens up a decompiled
class file, in a new tab.

00:04:36.760 --> 00:04:41.160
There are tools that'll take a class file, and
decompile it into source code, which can show

00:04:41.160 --> 00:04:47.200
you quite a bit of the implementation details.
In this case, I can see this is a typed interface,

00:04:47.200 --> 00:04:50.600
that extends Query.
If I hover over the name,

00:04:50.600 --> 00:04:56.080
TypedQuery, I can see that this interface
is part of the jakarta.persistence package.

00:04:56.080 --> 00:04:59.560
I'll pull this interface
up, in the Jakarta API docs.

00:05:01.640 --> 00:05:06.600
To find this link on your own, just google
the terms, jakarta and TypedQuery together,

00:05:06.600 --> 00:05:10.600
to find the latest version, or
most current version you can.

00:05:10.600 --> 00:05:14.240
I'll scroll down a bit on this page,
so you can see the list of methods,

00:05:14.240 --> 00:05:18.240
declared on this interface.
You'll see at the top of the list,

00:05:18.240 --> 00:05:22.480
there's the getResultList method,
which I'll be executing in this code.

00:05:22.480 --> 00:05:27.480
This is followed by getResultStream,
which returns a stream of the entity type.

00:05:27.480 --> 00:05:32.520
You know I like streams, so this method could be
particularly useful, for using stream operations

00:05:32.520 --> 00:05:36.760
we've become pretty familiar with.
This will let us quickly investigate,

00:05:36.760 --> 00:05:42.120
or manipulate query results.
Let me give you a word of caution though.

00:05:42.120 --> 00:05:46.640
You want to avoid, if you can, using
a stream to filter or limit results,

00:05:46.640 --> 00:05:50.080
though it might seem simpler.
It's usually a good idea to

00:05:50.080 --> 00:05:54.280
limit data going across a network.
If you can add the criteria to the

00:05:54.280 --> 00:05:58.720
where clause of the JPQL query that gets executed
on the server, you'll be better off than trying

00:05:58.720 --> 00:06:03.400
to filter the stream on the client side..
But you can imagine using the stream result

00:06:03.400 --> 00:06:07.880
to create some sort of Mapped collection,
based on column values in a table (as their

00:06:07.880 --> 00:06:11.600
translated to entity fields).
I'll be showing you an example

00:06:11.600 --> 00:06:15.040
of this in a little bit.
There's also getSingleResult,

00:06:15.040 --> 00:06:19.680
so maybe you only care about one entity,
though several might match your query.

00:06:19.680 --> 00:06:24.400
For example, if you've got a sorted query,
you might only want the first record,

00:06:24.400 --> 00:06:29.400
sometimes called the top, and this method
limits the data returned, to a single record.

00:06:30.040 --> 00:06:34.360
There's a couple of useful set methods,
and then a whole series of set Parameter

00:06:34.360 --> 00:06:38.520
methods, as you can see.
Getting back to the code,

00:06:38.520 --> 00:06:43.080
I'll run my first JPA query.
To do this, I need to add some

00:06:43.080 --> 00:06:46.360
code in the main method.
I'll set up a variable,

00:06:46.360 --> 00:06:52.880
for the results from the getArtistsJPQL method, so
a List of Artists, and I'll initialize it to null.

00:06:52.880 --> 00:06:57.960
Like I did previously, I'll first instantiate an
Entity Manager Factory from the Persistence type,

00:06:57.960 --> 00:07:02.760
within a try with resources declaration.
I'll pass that the name of my persistence

00:07:02.760 --> 00:07:09.880
unit. Hopefully you'll remember, I set this
up in the persistence.xml file. In this case,

00:07:09.880 --> 00:07:17.560
the persistence unit is named, dev dot lpa dot
music. Next, I create an Entity Manager instance,

00:07:17.560 --> 00:07:23.400
using a method on the factory, again this is still
in the try with resources declaration. I'll get

00:07:23.400 --> 00:07:28.240
back to the code that goes in the try block,
in a second. I'll just complete the statement

00:07:28.240 --> 00:07:33.560
with a catch block, Printing the stack trace of
any error I get, ignoring Intelli J's warning,

00:07:33.560 --> 00:07:40.040
that this isn't very robust handling of a problem.
My variable, artists, will get set to the result

00:07:40.040 --> 00:07:45.960
of calling my get Artists JPQL method.
When using JPA Queries, it's a good idea

00:07:45.960 --> 00:07:52.120
to wrap the queries in a transaction. I'll
get a transaction from the entity manager.

00:07:52.120 --> 00:07:58.440
I'll call transaction begin next. I need to pass
the entity manager variable, and then a string,

00:07:58.440 --> 00:08:03.080
and I'll just set that to an empty literal
string to start. You might have noticed,

00:08:03.080 --> 00:08:09.440
I never used the second parameter, in my method's
code block. I plan to change that code shortly,

00:08:09.440 --> 00:08:15.840
to use it. Finally, I'll print the results I
get back. I can use for each on the artists

00:08:15.840 --> 00:08:21.720
list variable, and a method reference, to print
each artist, that's in this resulting list.

00:08:21.720 --> 00:08:30.920
I'll call transaction commit here at the end.
You might be wondering why you need a transaction

00:08:30.920 --> 00:08:35.560
when you're just querying records.
This is kind of a complicated subject

00:08:35.560 --> 00:08:40.000
and has to do with lazy loading vs eager
fetching of dependent tables, as well as

00:08:40.000 --> 00:08:45.520
transactional integrity between related tables.
If you do have problems with your queries,

00:08:45.520 --> 00:08:50.640
and you're not including them in a transaction
block, let me recommend trying this to start.

00:08:50.640 --> 00:08:56.320
Now I'll run this code.
So you'll see, in the output,

00:08:56.320 --> 00:09:02.240
all of the artists in the table, in my
case that's 202 artists, that get printed.

00:09:02.240 --> 00:09:05.400
Each record contains all the
row data in each artist record,

00:09:05.400 --> 00:09:10.400
so that's just artist id and artist name.
Notice though, that each record also

00:09:10.400 --> 00:09:19.520
includes, all the artist's album records.
In my JPQL statement, when I specified, select a,

00:09:19.520 --> 00:09:25.560
from artist, I didn't specify what data I wanted,
meaning what fields that mapped to columns.

00:09:25.560 --> 00:09:29.160
So it returned all the data for
all the fields on this entity.

00:09:29.160 --> 00:09:33.720
You'll recall that I set up the entities, by
declaring a relationship on the albums field,

00:09:33.720 --> 00:09:39.600
a list, declared in artist, to the album entity.
All of the underlying database querying,

00:09:39.600 --> 00:09:45.560
with the appropriate joins was done seamlessly
by the JPA Provider, in this case hibernate.

00:09:45.560 --> 00:09:50.720
This means, I'm able to write a very simple,
generic query against an Artist entity class,

00:09:50.720 --> 00:09:55.680
to get related data, in this
case albums, for each artist.

00:09:55.680 --> 00:10:00.600
This doesn't require the developer retrieving
data, to know anything about inner or outer joins,

00:10:00.600 --> 00:10:06.360
or foreign keys, or any other specific
implementation details of the database.

00:10:06.360 --> 00:10:09.640
It also doesn't require
views, on the database server,

00:10:09.640 --> 00:10:15.160
for simpler querying of a normalized schema.
You may still want to employ those techniques,

00:10:15.160 --> 00:10:20.320
but in this case, none of that is
necessary, in the operation of this query.

00:10:20.320 --> 00:10:25.400
This might be a welcome relief, if you
don't want to deal with databases directly.

00:10:25.400 --> 00:10:31.480
Now, I'll alter the query slightly, this time
just getting artists whose name contains S T E V.

00:10:31.480 --> 00:10:37.360
First, I'll change my select statement.
I'll add a where clause, so I'll append the text,

00:10:37.360 --> 00:10:44.360
where, a.artistName, like, colon partialName.
In this case, you can see I'm using the attribute

00:10:44.360 --> 00:10:50.160
name on the Artist entity, and not the column name
in the table, which is artist underscore name.

00:10:50.160 --> 00:10:55.840
My placeholder parameter, which is called a named
parameter in this case, is specified by a colon,

00:10:55.840 --> 00:11:00.880
followed by any variable name I want.
So here, I'm calling it partial Name,

00:11:00.880 --> 00:11:05.760
since I'll match on part of the artist's name.
Next I need to actually pass a value,

00:11:05.760 --> 00:11:09.360
to this placeholder parameter.
So I'll add a call to a

00:11:09.360 --> 00:11:15.800
setParameter method, on the query variable.
One version of this method takes two strings.

00:11:15.800 --> 00:11:21.480
The first is the named parameter, so I'll pass
partialName as a string literal. The literal value

00:11:21.480 --> 00:11:27.320
should match the named parameter, used in your
JPQL statement. The second argument to the set

00:11:27.320 --> 00:11:32.320
parameter method, is the value to be used, so I'll
pass it the matched Value, the method argument

00:11:32.320 --> 00:11:36.520
that contains the criteria to match on.
Back In the main method,

00:11:36.520 --> 00:11:41.160
I'll change how I invoke this method.
Instead of passing an empty string literal,

00:11:41.160 --> 00:11:47.400
I'll pass a pattern, an S Q L pattern I mean.
Let me set this up, so first I include a percent

00:11:47.400 --> 00:11:55.400
sign, then S T E and V, and another percent sign.
The percent sign is the S Q L wildcard specifier,

00:11:55.400 --> 00:12:03.040
in a pattern, that's used by a LIKE clause in SQL.
It means match on zero, or many characters.

00:12:03.040 --> 00:12:08.840
Java's regular expression specifier to do
something similar, you'll remember, is a dot.

00:12:08.840 --> 00:12:13.960
Because I'm starting with a percent sign, this
will match the contiguous letters, S T E V,

00:12:13.960 --> 00:12:19.480
in any part of the album name.
I'll run that.

00:12:19.480 --> 00:12:23.880
You can see I get only 6 artists that matched
that, most of them start with the first name,

00:12:23.880 --> 00:12:28.600
Steve, but there's also Seasick
Steve, and Stevie Ray Vaughan.

00:12:28.600 --> 00:12:33.480
I could change my pattern, if I wanted only
artists whose names started with S T E V, by

00:12:33.480 --> 00:12:38.120
removing the first percent sign.
That would eliminate Seasick Steve,

00:12:38.120 --> 00:12:43.600
which you can try on your own, if you want to.
JPQL doesn't eliminate the need to understand

00:12:43.600 --> 00:12:50.080
all SQL constructs, as this example demonstrates.
In this code, you still needed to understand the

00:12:50.080 --> 00:12:54.400
LIKE clause and valid patterns,
to use it effectively here.

00:12:54.400 --> 00:12:58.840
In addition to named parameters, you can use
placement parameters in the query string.

00:12:59.480 --> 00:13:02.520
This is similar to the question
mark place holder which we saw,

00:13:02.520 --> 00:13:07.520
in the prepared and callable statements.
In this case, in addition to the question

00:13:07.520 --> 00:13:14.360
mark, you have to include a numeric value.
Numeric placeholder specifiers must start at 1.

00:13:14.360 --> 00:13:17.520
But they don't have to be in sequential
order, and you can reuse a numeric

00:13:17.520 --> 00:13:23.600
placeholder, in a single JPQL string.
I'll change my getArtistsPLQL method,

00:13:23.600 --> 00:13:28.840
replacing colon matched value, with a
question mark, followed by the number 1.

00:13:28.840 --> 00:13:34.320
I'll next change the setParameter method,
passing in the number 1, as the first argument.

00:13:34.320 --> 00:13:39.360
If I run the code this way,
I'll get the same results,

00:13:39.360 --> 00:13:44.360
as I did with a named parameter.
Named placeholders make more readable code,

00:13:44.360 --> 00:13:48.520
in my opinion, but it's up to you,
or maybe the framework you're using,

00:13:48.520 --> 00:13:53.640
which kind of placeholder type you'll use.
In this video, I've given you your first taste of

00:13:53.640 --> 00:14:00.600
using JPQL, with a very simple select statement.
The first brought back all data for all records,

00:14:00.600 --> 00:14:04.760
and the second query brought back all
data, for a limited set of records,

00:14:04.760 --> 00:14:11.080
matching criteria on the artist name.
I'll end this video here, before it gets too long.

00:14:11.080 --> 00:14:14.800
In the next video, I'll continue using
this project and this class's method,

00:14:14.800 --> 00:14:19.440
and show you slightly more complex JPQL
queries, so let's move on to that video.
