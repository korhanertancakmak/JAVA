# [Unmodifiable Collections Challenge]()
<div align="justify">

In this project, I have a package, **bank**,
that has my **BankAccount** and **BankCustomer** classes. 
I designed these to be immutable, 
but now I want to let customers withdraw or deposit funds, 
and I want to keep track of each transaction.
I'll create the **Transaction** class first:

```java  
public class Transaction {

    private int routingNumber;
    private long transactionId;
    private int customerId;
    private double amount;

    public Transaction(int routingNumber, long transactionId, int customerId, double amount) {
        this.routingNumber = routingNumber;
        this.transactionId = transactionId;
        this.customerId = customerId;
        this.amount = amount;
    }

    public int getRoutingNumber() {
        return routingNumber;
    }

    public void setRoutingNumber(int routingNumber) {
        this.routingNumber = routingNumber;
    }

    public long getTransactionId() {
        return transactionId;
    }

    public void setTransactionId(long transactionId) {
        this.transactionId = transactionId;
    }

    public int getCustomerId() {
        return customerId;
    }

    public void setCustomerId(int customerId) {
        this.customerId = customerId;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    @Override
    public String toString() {
        return "%015d:%020d:%015d:%012.2f".formatted(routingNumber, customerId, transactionId, amount);
    }
}
```

Emulating code that might get generated by tools, 
using database tables to produce them. 
I want this to be in the **dto** package. 
This class has four fields:

* The routing number is unique to a bank.
* The transaction id, that would be unique within each bank instance.
* The customer id, here it's an integer.
* The amount of the transaction, this is a double and could be negative.

Some DTOs have constructors and some don't. 
I'm going to include a constructor with all four fields, 
and I'll generate that. 
Frameworks that generate DTOs include getter 
and setter methods for every field, 
so I'll generate those. 
I'll include a _toString_ method, 
generating that but select no fields, so select _None_, 
and I'll replace the generated code.
I want to return a formatted **String** in its place. 
I'll start with a 15-digit zero filled routing number, 
followed by a 20-digit zero filled customer id, 
then a 15 digit zero filled transaction id. 
Lastly, 12 digits, zero filled, 
which includes a minus sign for a withdrawal, 
and two digits for the cents. 
That's a DTO, that'll be packaged with our banking code. 
Next, I'll work on the changes to my **BankAccount** class.

```java  
public class BankAccount {

    public enum AccountType {CHECKING, SAVINGS}

    private final AccountType accountType;
    private double balance;
    private final Map<Long, Transaction> transactions = new LinkedHashMap<>();

    BankAccount(AccountType accountType, double balance) {
        this.accountType = accountType;
        this.balance = balance;
    }

    public AccountType getAccountType() {
        return accountType;
    }

    public double getBalance() {
        return balance;
    }
}
```

First, I don't want balance to be _final_, 
so I'll remove the _final_ keyword. 
I'll add a collection of transactions,
and I have many options to choose from for this type. 
I could make this an array, a **list**, a **set**, or a **map**.
I'm going to go with **map**, 
in case I ever want to look up a transaction 
by its transaction id. 
I'll use Long as my key type, so the wrapper long, 
uppercase there, and **Transaction** is going 
to be the value type. 
I'll call it transactions,
and I'll initialize this to a new **LinkedHashMap**. 
It makes sense to have the map ordered, 
by the order they were added.
I'll generate a getter for that, 
placing it after _getBalance_. 
I'm not going to just return transactions here, 
instead I'll return an unmodifiable collection, 
to try to safeguard that data. 
Since my field is a **Map**, 
I can use the copy of method on **Map**, 
passing it my transactions. 
Finally, I want to provide a way 
to change the balance on an account.

```java  
void commitTransaction(int routingNumber, long transactionId, String customerId, double amount) {

    balance += amount;
    transactions.put(transactionId,
            new Transaction(routingNumber, transactionId, Integer.parseInt(customerId), amount));
}
```

I'll call this method _commitTransaction_. 
I'll make it package private, 
meaning only classes in this package can call it, 
so only the **Bank** or **BankCustomer** classes 
will be able to call it. 
I'll pass the bank routing number, 
the transaction id, the customer id, 
and the amount of the transaction. 
In this code, I'll just assume validation occurred already, 
and I'll adjust the balance. 
Remember, a withdrawal will come in as a negative number, 
so I can simply add the amount in either case. 
I'll also create a transaction and put it in this account's map. 
My customer id is a string with leading zeros, 
here I just want to pass the integer value, 
and let the transaction class format it in its own way. 
Ok, so that's it for the **BankAccount**. 
Next, I'll go to my **BankCustomer** class, 
and make the changes for this class.

```java  
public class BankCustomer {

    private static int lastCustomerId = 10_000_000;

    private final String name;
    private final int customerId;
    private final List<BankAccount> accounts = new ArrayList<>();

    BankCustomer(String name, double checkingAmount, double savingsAmount) {
        this.name = name;
        this.customerId = lastCustomerId++;
        accounts.add(new BankAccount(BankAccount.AccountType.CHECKING, checkingAmount));
        accounts.add(new BankAccount(BankAccount.AccountType.SAVINGS, savingsAmount));
    }

    public String getName() {
        return name;
    }

    public String getCustomerId() {
        return "%015d".formatted(customerId);
    }

    public List<BankAccount> getAccounts() {
        return List.copyOf(accounts);
    }

    public BankAccount getAccount(BankAccount.AccountType type) {

        for (var account : accounts) {
            if (account.getAccountType() == type) {
                return account;
            }
        }
        return null;
    }

    @Override
    public String toString() {

        String[] accountStrings = new String[accounts.size()];
        Arrays.setAll(accountStrings, i -> accounts.get(i).toString());
        return "Customer: %s (id:%015d)%n\t%s%n".formatted(name, customerId,
                String.join("\n\t", accountStrings));
    }
}
```

First, I want to make the constructor package private, 
so I'm not going to specify any access modifier 
on this constructor. 
I'll remove the public access modifier that's there now. 
Right now, I'll add a getter for customer id, 
putting that under _getName_.
I'll change this, though, to return a 15-digit string. 
To do this, I'll change the return type to a string. 
Instead of just returning the customer id, 
I'll return a formatted string that returns my customer id, 
with leading zeros, up to 15 characters. 
Next, I want to change the _getAccounts_ method, 
to return an unmodifiable collection, 
by using the copy of method, on _List_ this time. 
This will prevent any clients from adding, deleting 
or reassigning accounts, among other things. 
Lastly, I want to be able to get a customer account 
by the account type. 
I'll place this method after the _getAccounts_ method. 
I'll make this public, returning a **BankAccount**, 
and I'll call it _getAccount_, It will take an enum constant, 
an **AccountType** as the parameter. 
I'll return _null_ to start with. 
Next, I'll add code to loop through my list of accounts, 
returning the first account that matches the type passed. 
This isn't realistic for an actual bank, 
because you could have different multiple checking and 
savings accounts, but let's keep this simple. 
My code isn't compiling right now, because, 
as I mentioned previously, it's because of the code in 
the **Main** class's _main_ method.

```java  
public class Main {

    public static void main(String[] args) {
        //BankCustomer joe = new BankCustomer("Joe", 500.00, 10000.00);
        BankCustomer joe = null;
        System.out.println(joe);
    }
}
```

I made the **BankCustomer** constructor package private, 
so I can't instantiate a class from this method. 
What I'll do, so the code will compile, 
is just set joe to null for now. 
I wanted this code to compile. 
Ok, so let's build the bank. 
I'll create the Bank class, in my bank package.

```java  
public class Bank {

    public final int routingNumber;
    private long lastTransactionId = 1;
    private final Map<String, BankCustomer> customers;

    public Bank(int routingNumber) {
        this.routingNumber = routingNumber;
        customers = new HashMap<>();
    }

    public BankCustomer getCustomer(String id) {

        BankCustomer customer = customers.get(id);
        return customer;
    }
}
```

Every bank has a routing number that uniquely identifies it. 
This will get set when I create the bank, 
and it shouldn't change, so I'll make it _final_. 
Each **bank** instance will keep track of the 
last transaction id. 
This should be unique for every transaction. 
Because it's going to be changing constantly 
on the **bank** instance, I don't want it to be _final_, 
but I do want it private. 
By the way, I've made routing number public. 
It's final, and an int, so client code can't mutate it, 
and its matter of public record for most banks. 
I could have made this private and added a getter, 
so if you did it that way, it's perfectly acceptable. 
I also want a collection of customers. 
I'm going to make this final, and a map, 
so I can look up a customer by the customer id.
My key type is **String**, which will be the 15-digit customer id, 
and the value is a **BankCustomer**. 
I'll call this field customers. 
Now that I have the fields, I'll generate a constructor, 
but I only want to include the routing number. 
Now that I have this constructor, 
I'll add code to instantiate my customer map here. 
I'll make this a hash map. 
It's not really important that it's ordered, 
but it's more important for retrieval to be faster. 
For this class, I don't really want getters, 
though one for routing number might make sense. 
Instead, I just want a public method to get a **BankCustomer**, 
and that'll be called _getCustomer_.
It'll take a string, id, the customer's id 
for the **BankCustomer** I want to get. 
I'll look up the customer, by this id. 
I'll return this customer for the moment. 
I can't get a customer unless I have some setup on my bank,
so I need a method to add a new customer.

```java  
public void addCustomer(String name, double checkingInitialDeposit, double savingsInitialDeposit) {

    BankCustomer customer = new BankCustomer(name, checkingInitialDeposit, savingsInitialDeposit);

    customers.put(customer.getCustomerId(), customer);
}
```

I could return a boolean, to indicate success or not. 
Or I could return the **Customer** object created, 
but I don't want to do that here. 
Instead, I'll keep this simple, and just make it void. 
It will take a name, an _initialDeposit_ 
for the checking account, and an initial deposit f
or savings. 
I'm going to create a new **BankCustomer** instance, 
passing the name and deposit amounts. 
This is how we created a customer in the first challenge. 
The difference now is 
that I can only create a **BankCustomer** instance, 
from code in classes, in this package only. 
I'll add this new customer to the bank's customer map, 
using the String I get back from get customer id, as the key. 
Finally, I'll code the crucial method, _doTransaction_.

```java  
public boolean doTransaction(String id, BankAccount.AccountType accountType, double amount) {

    BankCustomer customer = customers.get(id);
    if (customer != null) {
        BankAccount account = customer.getAccount(accountType);
        if (account != null) {
            if ((account.getBalance() + amount) < 0) {
                System.out.println("Insufficient funds");
            } else {
                account.commitTransaction(routingNumber, lastTransactionId++, id, amount);
                return true;
            }
        }
    } else {
        System.out.println("Invalid customer id");
    }
    return false;
}
```

I'll set this up as a public method, returning a boolean, 
which will be true if the transaction was successfully processed. 
It will take the customer id, a bank account type and an amount. 
I'll get the customer instance, using the id. 
I'll have this method return false, as the default value. 
Continuing after I get my **BankCustomer**, 
I'll make sure I got a valid customer back. 
I'll have an if statement, checking if customer is not _null_.
If that's the case, I can get the account from my customer, 
using the account type.
If customer is _null_, meaning I couldn't get it 
based on the id passed, I'll print out that 
it's an invalid customer id. 
Ok, so now I have to make sure I got an account back from that, 
so I'll check if the account is not _null_. 
If the account exists, meaning the account isn't _null_, 
I'll check if adding that amount to the balance would result 
in a balance less than zero. 
This would only happen if the amount is negative, 
and there weren't enough funds for the withdrawal. 
If this is the case, I'll print insufficient funds. 
If the amount is positive, a deposit in other words,
or the previous check wasn't true, meaning there are enough 
funds in the account for this withdrawal, then I'll return true. 
Ok, so that's the banking application.
But how secure is it?
Let's go test it out in the **Main** class's _main_ method.

```java  
public class Main {

    public static void main(String[] args) {

        //BankCustomer joe = null;
        Bank bank = new Bank(3214567);
        bank.addCustomer("Joe", 500.00, 10000.00);

        BankCustomer joe = bank.getCustomer("000000010000000");
        System.out.println(joe);
        
        List<BankAccount> accounts = joe.getAccounts();
        accounts.clear();
        System.out.println(joe);
    }
}
```

First, I want to create a **Bank** instance. 
I'll insert this code above the _BankCustomer joe = null;_ 
statement.
I'll create a variable _bank_, and assign that a new bank, 
passing that a routing number. 
I'll add a bank customer, _Joe_, with the same deposits as before. 
I need to retrieve _Joe_ from the bank's method, 
so instead of assigning null to _joe_, 
I'll assign him the result of the _getCustomer_ method on my new bank. 
I know I started with ten million as the first bank customer id. 
So that's eight digits. 
I'll add seven leading zeros, 10, 
and another 6 zeros to get our 15-digit customer id, 
which should give me _Joe_. 
And I'll print out _joe_. 
Running this code:

```html  
Customer: Joe (id:000000010000000)
CHECKING $500,00
SAVINGS $10000,00

Exception in thread "main" java.lang.UnsupportedOperationException
at java.base/java.util.ImmutableCollections.uoe
```

I get the same output I got before, 
but I also get an exception in the code, 
where I try to clear the account data.
This is the benefit of returning an 
unmodifiable collection. 
I'll comment those last three statements.

```java  
public class Main {

    public static void main(String[] args) {

        //BankCustomer joe = null;
        Bank bank = new Bank(3214567);
        bank.addCustomer("Joe", 500.00, 10000.00);

        BankCustomer joe = bank.getCustomer("000000010000000");
        System.out.println(joe);
        
        //List<BankAccount> accounts = joe.getAccounts();
        //accounts.clear();
        //System.out.println(joe);

        if (bank.doTransaction(joe.getCustomerId(), BankAccount.AccountType.CHECKING, 35)) {
            System.out.println(joe);
        }
    }
}
```

Now, I'll add some funds to Joe's account, 
calling the _doTransaction_ method on **Bank** to do it. 
This method returns a boolean, 
so I'll put it in an if statement.
I'll pass the customer id, _Checking_ for the account type, 
and 35 dollars. 
If that's successful, 
I'll print out Joe's account again. 
Running that code:

```html  
Customer: Joe (id:000000010000000)
CHECKING $500,00
SAVINGS $10000,00

Customer: Joe (id:000000010000000)
CHECKING $535,00
SAVINGS $10000,00
```
                    
You can see Joe's checking account balance has gone up.

```java  
if (bank.doTransaction(joe.getCustomerId(), BankAccount.AccountType.CHECKING, -535)) {
    System.out.println(joe);
}
```

I'll copy that last if statement, and paste a copy right below it, 
changing the amount to -535. 
And running this:

```html  
Customer: Joe (id:000000010000000)
CHECKING $500,00
SAVINGS $10000,00

Customer: Joe (id:000000010000000)
CHECKING $535,00
SAVINGS $10000,00

Customer: Joe (id:000000010000000)
CHECKING $0,00
SAVINGS $10000,00
```
                    
You can see I can empty the account of every dollar.

```java  
if (bank.doTransaction(joe.getCustomerId(), BankAccount.AccountType.CHECKING, -0.01)) {
    System.out.println(joe);
}
```

I'll change that to withdraw a penny over. 
Running that:

```html  
Customer: Joe (id:000000010000000)
CHECKING $500,00
SAVINGS $10000,00

Customer: Joe (id:000000010000000)
CHECKING $535,00
SAVINGS $10000,00

Customer: Joe (id:000000010000000)
CHECKING $0,00
SAVINGS $10000,00

Insufficient funds
```
                    
I can confirm that I get insufficient funds, 
and can't withdraw the funds, 
so the checking amount stays at 535. 
I'll comment that last change, 
because I want to have a couple of 
good transactions in my account.

```java  
BankAccount checking = joe.getAccount(BankAccount.AccountType.CHECKING);
var transactions = checking.getTransactions();
transactions.forEach((k, v) -> System.out.println(k + ": " + v));
```

Next, I'll get the checking account 
from the Joe's **BankCustomer** instance. 
I can get the transactions from that account.
And I'll print the transactions.
Running that:

```html  
Customer: Joe (id:000000010000000)
CHECKING $0,00
SAVINGS $10000,00

1: 000000003214567:00000000000010000000:000000000000001:000000035,00
2: 000000003214567:00000000000010000000:000000000000002:-00000535,00
```
                    
You can see my transactions printed in a banky kind of way.
You might notice they're not in order. 
The returned map is not guaranteed to be ordered, 
in the same matter as the map from which it was created. 
I'll see if I can modify those checking account transactions next.

```java  
transactions.put(3L, new Transaction(1,1,Integer.parseInt(joe.getCustomerId()),500).toString());
```

I'll try to add a new transaction directly 
to the _transactions_ variable. 
Running this code:

```html  
1: 000000003214567:00000000000010000000:000000000000001:000000035,00
2: 000000003214567:00000000000010000000:000000000000002:-00000535,00
```

I get same _transactions_ so that's a good thing. 
I shouldn't be able to just modify this _transactions_ collections,
once I get a reference to it. 
But is this code really safe?

```java  
System.out.println("---------------------");
for (var tx : transactions.values()) {
    tx.getCustomerId();
    tx.setAmount(10000.00);
}
transactions.forEach((k, v) -> System.out.println(k + ": " + v));
```

I'll revert that last change, 
removing that statement all together. 
Instead, I'll loop through the transactions,
and I'll just see if I can tamper with each individual transaction. 
I'll add a separation line. 
Looping through the transactions of my local variable, 
I'll set the customer id to 2. 
I'll change each transaction amount to 10 thousand dollars. 
And I'll again print these transactions. 
Running that:

```html  
---------------------
1: 000000003214567:00000000000010000000:000000000000001:000010000,00
2: 000000003214567:00000000000010000000:000000000000002:000010000,00
```
                    
You see that it not only compiles and runs, 
but it looks like my transactions have changed? 
Have they changed on Joe's account, or just on this copy? 
To answer that question, I'll get the joe's account again 
and the transactions on that.

```java  
System.out.println("---------------------");
joe.getAccount(BankAccount.AccountType.CHECKING).getTransactions().
        forEach((k, v) -> System.out.println(k + ": " + v));
```

I'll add another separator line. 
I'll call get account directly on joe, 
getting the checking account, 
and chain a call to getTransactions, 
so I'm again getting transactions off of Joe's data, 
not local variables.
I'll print these transactions.
Running that:

```html  
---------------------
1: 000000003214567:00000000000010000000:000000000000001:000010000,00
2: 000000003214567:00000000000010000000:000000000000002:000010000,00
```

I hope you're cringing a little. 
Ouch! 
Our client can change data on our **BankCustomer**'s account. 
We put in a lot of effort to prevent this behavior. 
What could we do to fix this? 
Maybe we want to create a deep copy of the account.
This would mean creating a copy, not only of the _transactions_ list, 
but each individual transaction as well. 
I could also return a different kind of Map from this method. 
In fact, this is what I'll do. 
I'll go to the _getTransactions_ method on **Bank** Account.

```java  
public Map<Long, String> getTransactions() {

    Map<Long, String> txMap = new LinkedHashMap<>();
    for (var tx : transactions.entrySet()) {
        txMap.put(tx.getKey(), tx.getValue().toString());
    }
    return txMap;
}
```

Instead of returning an unmodifiable map, containing mutable data, 
I'll instead return a map of immutable instances, Strings. 
This will provide the same behavior, 
without exposing the data to dangerous side effects. 
To do this, I'll change the return type of this method 
from returning a map, keyed by long, with transaction values, 
to still be keyed by long, but with String values instead. 
I'll next set up a local variable, a map, again with the key long, 
with a value of String, I'll call that _txMap_. 
I'll set that to a new **LinkedHashMap**. 
I'll loop through the map's entries.
I'll insert the same key, so _transaction_ get key, 
but the value won't be the transaction, 
but the string value for transaction. 
I'll return this map. 
Now, my _main_ method,

```java  
joe.getAccount(BankAccount.AccountType.CHECKING).getTransactions().clear();
System.out.println("---------------------");
joe.getAccount(BankAccount.AccountType.CHECKING).getTransactions().
        forEach((k, v) -> System.out.println(k + ": " + v));
```

The code doesn't compile, and that's a good thing. 
I haven't exposed the transaction instances to the client, 
but I've been able to use the **Transaction** class in my model. 
I'll comment out that whole for loop code. 
Instead of that code, I'll try to clear joe's transactions.
I'll get the checking account, get the transactions on that, 
and invoke the _clear_ method on that. 
This code compiles and runs:

```html  
1: 000000003214567:00000000000010000000:000000000000001:000000035,00
2: 000000003214567:00000000000010000000:000000000000002:-00000535,00
---------------------
1: 000000003214567:00000000000010000000:000000000000001:000000035,00
2: 000000003214567:00000000000010000000:000000000000002:-00000535,00
```
                
But it has no effect on Joe's transactions. 
I passed back a modifiable collection, with immutable data. 
This was more secure than passing back an unmodifiable collection 
that has mutable instances. 
You want to be really careful about what you return from mutable classes, 
because the mutable object could be buried several layers deep. 
You could try to do deep copies, 
or if there's no real reason for the client to have access 
to the full functionality of the instances, 
return alternative immutable instances 
that contain the information they may be interested in.
Ok, so I hope you got something out of that, 
and can see the value of using immutable classes. 
Don't assume just using an unmodifiable collection 
is going to be good enough. 
Combining immutable classes with unmodifiable collections 
gives you the best protection for your data. 
</div>
